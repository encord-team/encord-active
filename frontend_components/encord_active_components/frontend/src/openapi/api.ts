/* tslint:disable */
/* eslint-disable */
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from "./base";

/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const AnalysisBuckets = {
  NUMBER_10: 10,
  NUMBER_100: 100,
  NUMBER_1000: 1000,
} as const;

export type AnalysisBuckets =
  (typeof AnalysisBuckets)[keyof typeof AnalysisBuckets];

/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const AnalysisDomain = {
  Data: "data",
  Annotation: "annotation",
} as const;

export type AnalysisDomain =
  (typeof AnalysisDomain)[keyof typeof AnalysisDomain];

/**
 *
 * @export
 * @interface AnalysisSearch
 */
export interface AnalysisSearch {
  /**
   *
   * @type {boolean}
   * @memberof AnalysisSearch
   */
  truncated: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof AnalysisSearch
   */
  results: Array<string>;
}
/**
 *
 * @export
 * @interface CreateProjectSubsetPostAction
 */
export interface CreateProjectSubsetPostAction {
  /**
   *
   * @type {string}
   * @memberof CreateProjectSubsetPostAction
   */
  project_title: string;
  /**
   *
   * @type {string}
   * @memberof CreateProjectSubsetPostAction
   */
  project_description?: string;
  /**
   *
   * @type {string}
   * @memberof CreateProjectSubsetPostAction
   */
  dataset_title: string;
  /**
   *
   * @type {string}
   * @memberof CreateProjectSubsetPostAction
   */
  dataset_description?: string;
  /**
   *
   * @type {SearchFilters}
   * @memberof CreateProjectSubsetPostAction
   */
  filters: SearchFilters;
}
/**
 *
 * @export
 * @interface DomainSearchFilters
 */
export interface DomainSearchFilters {
  /**
   *
   * @type {{ [key: string]: Array<number> | undefined; }}
   * @memberof DomainSearchFilters
   */
  metrics: { [key: string]: Array<number> | undefined };
  /**
   *
   * @type {{ [key: string]: Array<string> | undefined; }}
   * @memberof DomainSearchFilters
   */
  enums: { [key: string]: Array<string> | undefined };
  /**
   *
   * @type {Embedding2DFilter}
   * @memberof DomainSearchFilters
   */
  reduction?: Embedding2DFilter;
  /**
   *
   * @type {Array<string>}
   * @memberof DomainSearchFilters
   */
  tags?: Array<string>;
}
/**
 *
 * @export
 * @interface Embedding2DFilter
 */
export interface Embedding2DFilter {
  /**
   *
   * @type {string}
   * @memberof Embedding2DFilter
   */
  reduction_hash: string;
  /**
   *
   * @type {number}
   * @memberof Embedding2DFilter
   */
  x1: number;
  /**
   *
   * @type {number}
   * @memberof Embedding2DFilter
   */
  x2: number;
  /**
   *
   * @type {number}
   * @memberof Embedding2DFilter
   */
  y1: number;
  /**
   *
   * @type {number}
   * @memberof Embedding2DFilter
   */
  y2: number;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const EmbeddingReductionType = {
  Umap: "umap",
} as const;

export type EmbeddingReductionType =
  (typeof EmbeddingReductionType)[keyof typeof EmbeddingReductionType];

/**
 *
 * @export
 * @interface EnumSummary
 */
export interface EnumSummary {
  /**
   *
   * @type {string}
   * @memberof EnumSummary
   */
  title: string;
  /**
   *
   * @type {{ [key: string]: string | undefined; }}
   * @memberof EnumSummary
   */
  values?: { [key: string]: string | undefined };
  /**
   *
   * @type {EnumType}
   * @memberof EnumSummary
   */
  type: EnumType;
}

/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const EnumType = {
  Ontology: "ontology",
  Enum: "enum",
} as const;

export type EnumType = (typeof EnumType)[keyof typeof EnumType];

/**
 *
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
  /**
   *
   * @type {Array<ValidationError>}
   * @memberof HTTPValidationError
   */
  detail?: Array<ValidationError>;
}
/**
 *
 * @export
 * @interface ListProjectPredictionResult
 */
export interface ListProjectPredictionResult {
  /**
   *
   * @type {number}
   * @memberof ListProjectPredictionResult
   */
  total: number;
  /**
   *
   * @type {Array<ListProjectPredictionResultEntry>}
   * @memberof ListProjectPredictionResult
   */
  results: Array<ListProjectPredictionResultEntry>;
}
/**
 *
 * @export
 * @interface ListProjectPredictionResultEntry
 */
export interface ListProjectPredictionResultEntry {
  /**
   *
   * @type {string}
   * @memberof ListProjectPredictionResultEntry
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ListProjectPredictionResultEntry
   */
  prediction_hash: string;
}
/**
 *
 * @export
 * @interface LocationInner
 */
export interface LocationInner {}
/**
 *
 * @export
 * @interface MetricDissimilarityResult
 */
export interface MetricDissimilarityResult {
  /**
   *
   * @type {{ [key: string]: number | undefined; }}
   * @memberof MetricDissimilarityResult
   */
  results: { [key: string]: number | undefined };
}
/**
 *
 * @export
 * @interface MetricSummary
 */
export interface MetricSummary {
  /**
   *
   * @type {string}
   * @memberof MetricSummary
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof MetricSummary
   */
  short_desc: string;
  /**
   *
   * @type {string}
   * @memberof MetricSummary
   */
  long_desc: string;
  /**
   *
   * @type {MetricType}
   * @memberof MetricSummary
   */
  type: MetricType;
}

/**
 * Type of the metric
 * @export
 * @enum {string}
 */

export const MetricType = {
  Normal: "normal",
  Uint: "uint",
  Ufloat: "ufloat",
} as const;

export type MetricType = (typeof MetricType)[keyof typeof MetricType];

/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const PredictionDomain = {
  A: "a",
  P: "p",
  Tp: "tp",
  Fp: "fp",
  Fn: "fn",
} as const;

export type PredictionDomain =
  (typeof PredictionDomain)[keyof typeof PredictionDomain];

/**
 *
 * @export
 * @interface PredictionItem
 */
export interface PredictionItem {
  /**
   *
   * @type {{ [key: string]: { [key: string]: number | undefined; } | undefined; }}
   * @memberof PredictionItem
   */
  annotation_metrics: {
    [key: string]: { [key: string]: number | undefined } | undefined;
  };
  /**
   *
   * @type {Array<object>}
   * @memberof PredictionItem
   */
  objects: Array<object>;
  /**
   *
   * @type {Array<object>}
   * @memberof PredictionItem
   */
  classifications: Array<object>;
  /**
   *
   * @type {string}
   * @memberof PredictionItem
   */
  label_hash: string;
}
/**
 *
 * @export
 * @interface PredictionPRPoint
 */
export interface PredictionPRPoint {
  /**
   *
   * @type {number}
   * @memberof PredictionPRPoint
   */
  p: number;
  /**
   *
   * @type {number}
   * @memberof PredictionPRPoint
   */
  r: number;
}
/**
 *
 * @export
 * @interface PredictionQuery2DEmbedding
 */
export interface PredictionQuery2DEmbedding {
  /**
   *
   * @type {number}
   * @memberof PredictionQuery2DEmbedding
   */
  count: number;
  /**
   *
   * @type {Array<PredictionQueryScatterPoint>}
   * @memberof PredictionQuery2DEmbedding
   */
  reductions: Array<PredictionQueryScatterPoint>;
}
/**
 *
 * @export
 * @interface PredictionQueryScatterPoint
 */
export interface PredictionQueryScatterPoint {
  /**
   *
   * @type {number}
   * @memberof PredictionQueryScatterPoint
   */
  x: number;
  /**
   *
   * @type {number}
   * @memberof PredictionQueryScatterPoint
   */
  y: number;
  /**
   *
   * @type {number}
   * @memberof PredictionQueryScatterPoint
   */
  n: number;
  /**
   *
   * @type {number}
   * @memberof PredictionQueryScatterPoint
   */
  tp: number;
  /**
   *
   * @type {number}
   * @memberof PredictionQueryScatterPoint
   */
  fp: number;
  /**
   *
   * @type {number}
   * @memberof PredictionQueryScatterPoint
   */
  fn: number;
}
/**
 *
 * @export
 * @interface PredictionSummaryFeatureResult
 */
export interface PredictionSummaryFeatureResult {
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryFeatureResult
   */
  ap: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryFeatureResult
   */
  ar: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryFeatureResult
   */
  p: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryFeatureResult
   */
  r: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryFeatureResult
   */
  f1: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryFeatureResult
   */
  tp: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryFeatureResult
   */
  fp: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryFeatureResult
   */
  fn: number;
}
/**
 *
 * @export
 * @interface PredictionSummaryResult
 */
export interface PredictionSummaryResult {
  /**
   *
   * @type {boolean}
   * @memberof PredictionSummaryResult
   */
  classification_only: boolean;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryResult
   */
  classification_tTN?: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryResult
   */
  classification_accuracy?: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryResult
   */
  num_frames: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryResult
   */
  mAP: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryResult
   */
  mAR: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryResult
   */
  mP: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryResult
   */
  mR: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryResult
   */
  mF1: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryResult
   */
  tTP: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryResult
   */
  tFP: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryResult
   */
  tFN: number;
  /**
   *
   * @type {{ [key: string]: PredictionSummaryFeatureResult | undefined; }}
   * @memberof PredictionSummaryResult
   */
  feature_properties: {
    [key: string]: PredictionSummaryFeatureResult | undefined;
  };
  /**
   *
   * @type {{ [key: string]: Array<PredictionPRPoint> | undefined; }}
   * @memberof PredictionSummaryResult
   */
  prs: { [key: string]: Array<PredictionPRPoint> | undefined };
  /**
   *
   * @type {{ [key: string]: number | undefined; }}
   * @memberof PredictionSummaryResult
   */
  correlation: { [key: string]: number | undefined };
  /**
   *
   * @type {{ [key: string]: number | undefined; }}
   * @memberof PredictionSummaryResult
   */
  importance: { [key: string]: number | undefined };
}
/**
 *
 * @export
 * @interface ProjectDomainSummary
 */
export interface ProjectDomainSummary {
  /**
   *
   * @type {{ [key: string]: MetricSummary | undefined; }}
   * @memberof ProjectDomainSummary
   */
  metrics: { [key: string]: MetricSummary | undefined };
  /**
   *
   * @type {{ [key: string]: EnumSummary | undefined; }}
   * @memberof ProjectDomainSummary
   */
  enums: { [key: string]: EnumSummary | undefined };
}
/**
 *
 * @export
 * @interface ProjectItem
 */
export interface ProjectItem {
  /**
   *
   * @type {{ [key: string]: number | undefined; }}
   * @memberof ProjectItem
   */
  data_metrics: { [key: string]: number | undefined };
  /**
   *
   * @type {{ [key: string]: { [key: string]: number | undefined; } | undefined; }}
   * @memberof ProjectItem
   */
  annotation_metrics: {
    [key: string]: { [key: string]: number | undefined } | undefined;
  };
  /**
   *
   * @type {Array<object>}
   * @memberof ProjectItem
   */
  objects: Array<object>;
  /**
   *
   * @type {Array<object>}
   * @memberof ProjectItem
   */
  classifications: Array<object>;
  /**
   *
   * @type {string}
   * @memberof ProjectItem
   */
  dataset_title: string;
  /**
   *
   * @type {string}
   * @memberof ProjectItem
   */
  dataset_hash: string;
  /**
   *
   * @type {string}
   * @memberof ProjectItem
   */
  data_title: string;
  /**
   *
   * @type {string}
   * @memberof ProjectItem
   */
  data_hash: string;
  /**
   *
   * @type {string}
   * @memberof ProjectItem
   */
  label_hash: string;
  /**
   *
   * @type {number}
   * @memberof ProjectItem
   */
  num_frames: number;
  /**
   *
   * @type {number}
   * @memberof ProjectItem
   */
  frames_per_second?: number;
  /**
   *
   * @type {string}
   * @memberof ProjectItem
   */
  data_type: string;
  /**
   *
   * @type {string}
   * @memberof ProjectItem
   */
  url: string;
  /**
   *
   * @type {number}
   * @memberof ProjectItem
   */
  timestamp?: number;
}
/**
 *
 * @export
 * @interface ProjectList2DEmbeddingReductionResult
 */
export interface ProjectList2DEmbeddingReductionResult {
  /**
   *
   * @type {number}
   * @memberof ProjectList2DEmbeddingReductionResult
   */
  total: number;
  /**
   *
   * @type {Array<ProjectList2DEmbeddingReductionResultEntry>}
   * @memberof ProjectList2DEmbeddingReductionResult
   */
  results: Array<ProjectList2DEmbeddingReductionResultEntry>;
}
/**
 *
 * @export
 * @interface ProjectList2DEmbeddingReductionResultEntry
 */
export interface ProjectList2DEmbeddingReductionResultEntry {
  /**
   *
   * @type {string}
   * @memberof ProjectList2DEmbeddingReductionResultEntry
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ProjectList2DEmbeddingReductionResultEntry
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof ProjectList2DEmbeddingReductionResultEntry
   */
  hash: string;
  /**
   *
   * @type {EmbeddingReductionType}
   * @memberof ProjectList2DEmbeddingReductionResultEntry
   */
  type: EmbeddingReductionType;
}

/**
 *
 * @export
 * @interface ProjectMetadata
 */
export interface ProjectMetadata {
  /**
   *
   * @type {number}
   * @memberof ProjectMetadata
   */
  data_count: number;
  /**
   *
   * @type {number}
   * @memberof ProjectMetadata
   */
  annotation_count: number;
  /**
   *
   * @type {number}
   * @memberof ProjectMetadata
   */
  class_count: number;
}
/**
 *
 * @export
 * @interface ProjectSandboxEntry
 */
export interface ProjectSandboxEntry {
  /**
   *
   * @type {string}
   * @memberof ProjectSandboxEntry
   */
  project_hash: string;
  /**
   *
   * @type {string}
   * @memberof ProjectSandboxEntry
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof ProjectSandboxEntry
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof ProjectSandboxEntry
   */
  sandbox_url: string;
  /**
   *
   * @type {number}
   * @memberof ProjectSandboxEntry
   */
  data_count: number;
  /**
   *
   * @type {number}
   * @memberof ProjectSandboxEntry
   */
  annotation_count: number;
  /**
   *
   * @type {number}
   * @memberof ProjectSandboxEntry
   */
  class_count: number;
}
/**
 *
 * @export
 * @interface ProjectSearchEntry
 */
export interface ProjectSearchEntry {
  /**
   *
   * @type {string}
   * @memberof ProjectSearchEntry
   */
  project_hash: string;
  /**
   *
   * @type {string}
   * @memberof ProjectSearchEntry
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof ProjectSearchEntry
   */
  description: string;
  /**
   *
   * @type {boolean}
   * @memberof ProjectSearchEntry
   */
  sandbox: boolean;
}
/**
 *
 * @export
 * @interface ProjectSearchResult
 */
export interface ProjectSearchResult {
  /**
   *
   * @type {Array<ProjectSearchEntry>}
   * @memberof ProjectSearchResult
   */
  projects: Array<ProjectSearchEntry>;
  /**
   *
   * @type {Array<ProjectSandboxEntry>}
   * @memberof ProjectSearchResult
   */
  sandbox_projects: Array<ProjectSandboxEntry>;
}
/**
 *
 * @export
 * @interface ProjectSummary
 */
export interface ProjectSummary {
  /**
   *
   * @type {string}
   * @memberof ProjectSummary
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ProjectSummary
   */
  description: string;
  /**
   *
   * @type {object}
   * @memberof ProjectSummary
   */
  ontology: object;
  /**
   *
   * @type {boolean}
   * @memberof ProjectSummary
   */
  local_project: boolean;
  /**
   *
   * @type {ProjectDomainSummary}
   * @memberof ProjectSummary
   */
  data: ProjectDomainSummary;
  /**
   *
   * @type {ProjectDomainSummary}
   * @memberof ProjectSummary
   */
  annotation: ProjectDomainSummary;
  /**
   *
   * @type {number}
   * @memberof ProjectSummary
   */
  du_count: number;
  /**
   *
   * @type {number}
   * @memberof ProjectSummary
   */
  frame_count: number;
  /**
   *
   * @type {number}
   * @memberof ProjectSummary
   */
  annotation_count: number;
  /**
   *
   * @type {number}
   * @memberof ProjectSummary
   */
  classification_count: number;
  /**
   *
   * @type {ProjectDomainSummary}
   * @memberof ProjectSummary
   */
  data_annotation: ProjectDomainSummary;
  /**
   *
   * @type {{ [key: string]: string | undefined; }}
   * @memberof ProjectSummary
   */
  tags: { [key: string]: string | undefined };
  /**
   *
   * @type {string}
   * @memberof ProjectSummary
   */
  preview?: string;
}
/**
 *
 * @export
 * @interface Query2DEmbedding
 */
export interface Query2DEmbedding {
  /**
   *
   * @type {number}
   * @memberof Query2DEmbedding
   */
  count: number;
  /**
   *
   * @type {Array<QueryScatterPoint>}
   * @memberof Query2DEmbedding
   */
  reductions: Array<QueryScatterPoint>;
}
/**
 *
 * @export
 * @interface QueryDistribution
 */
export interface QueryDistribution {
  /**
   *
   * @type {Array<QueryDistributionGroup>}
   * @memberof QueryDistribution
   */
  results: Array<QueryDistributionGroup>;
}
/**
 *
 * @export
 * @interface QueryDistributionGroup
 */
export interface QueryDistributionGroup {
  /**
   *
   * @type {string}
   * @memberof QueryDistributionGroup
   */
  group: string;
  /**
   *
   * @type {number}
   * @memberof QueryDistributionGroup
   */
  count: number;
}
/**
 *
 * @export
 * @interface QueryEnumSummary
 */
export interface QueryEnumSummary {
  /**
   *
   * @type {number}
   * @memberof QueryEnumSummary
   */
  count: number;
}
/**
 *
 * @export
 * @interface QueryMetricPerformance
 */
export interface QueryMetricPerformance {
  /**
   *
   * @type {{ [key: string]: Array<QueryMetricPerformanceEntry> | undefined; }}
   * @memberof QueryMetricPerformance
   */
  precision: { [key: string]: Array<QueryMetricPerformanceEntry> | undefined };
  /**
   *
   * @type {{ [key: string]: Array<QueryMetricPerformanceEntry> | undefined; }}
   * @memberof QueryMetricPerformance
   */
  fns: { [key: string]: Array<QueryMetricPerformanceEntry> | undefined };
}
/**
 *
 * @export
 * @interface QueryMetricPerformanceEntry
 */
export interface QueryMetricPerformanceEntry {
  /**
   *
   * @type {number}
   * @memberof QueryMetricPerformanceEntry
   */
  m: number;
  /**
   *
   * @type {number}
   * @memberof QueryMetricPerformanceEntry
   */
  a: number;
  /**
   *
   * @type {number}
   * @memberof QueryMetricPerformanceEntry
   */
  n: number;
}
/**
 *
 * @export
 * @interface QueryMetricSummary
 */
export interface QueryMetricSummary {
  /**
   *
   * @type {number}
   * @memberof QueryMetricSummary
   */
  min: number;
  /**
   *
   * @type {number}
   * @memberof QueryMetricSummary
   */
  q1: number;
  /**
   *
   * @type {number}
   * @memberof QueryMetricSummary
   */
  median: number;
  /**
   *
   * @type {number}
   * @memberof QueryMetricSummary
   */
  q3: number;
  /**
   *
   * @type {number}
   * @memberof QueryMetricSummary
   */
  max: number;
  /**
   *
   * @type {number}
   * @memberof QueryMetricSummary
   */
  count: number;
  /**
   *
   * @type {number}
   * @memberof QueryMetricSummary
   */
  moderate: number;
  /**
   *
   * @type {number}
   * @memberof QueryMetricSummary
   */
  severe: number;
}
/**
 *
 * @export
 * @interface QueryScatter
 */
export interface QueryScatter {
  /**
   *
   * @type {Array<QueryScatterPoint>}
   * @memberof QueryScatter
   */
  samples: Array<QueryScatterPoint>;
}
/**
 *
 * @export
 * @interface QueryScatterPoint
 */
export interface QueryScatterPoint {
  /**
   *
   * @type {number}
   * @memberof QueryScatterPoint
   */
  x: number;
  /**
   *
   * @type {number}
   * @memberof QueryScatterPoint
   */
  y: number;
  /**
   *
   * @type {number}
   * @memberof QueryScatterPoint
   */
  n: number;
}
/**
 *
 * @export
 * @interface QuerySummary
 */
export interface QuerySummary {
  /**
   *
   * @type {number}
   * @memberof QuerySummary
   */
  count: number;
  /**
   *
   * @type {{ [key: string]: QueryMetricSummary | undefined; }}
   * @memberof QuerySummary
   */
  metrics: { [key: string]: QueryMetricSummary | undefined };
  /**
   *
   * @type {{ [key: string]: QueryEnumSummary | undefined; }}
   * @memberof QuerySummary
   */
  enums: { [key: string]: QueryEnumSummary | undefined };
}
/**
 *
 * @export
 * @interface SearchFilters
 */
export interface SearchFilters {
  /**
   *
   * @type {DomainSearchFilters}
   * @memberof SearchFilters
   */
  data?: DomainSearchFilters;
  /**
   *
   * @type {DomainSearchFilters}
   * @memberof SearchFilters
   */
  annotation?: DomainSearchFilters;
}
/**
 *
 * @export
 * @interface SimilarityResult
 */
export interface SimilarityResult {
  /**
   *
   * @type {string}
   * @memberof SimilarityResult
   */
  item: string;
  /**
   *
   * @type {number}
   * @memberof SimilarityResult
   */
  similarity: number;
}
/**
 *
 * @export
 * @interface UploadProjectToEncordPostAction
 */
export interface UploadProjectToEncordPostAction {
  /**
   *
   * @type {string}
   * @memberof UploadProjectToEncordPostAction
   */
  project_title: string;
  /**
   *
   * @type {string}
   * @memberof UploadProjectToEncordPostAction
   */
  project_description?: string;
  /**
   *
   * @type {string}
   * @memberof UploadProjectToEncordPostAction
   */
  dataset_title: string;
  /**
   *
   * @type {string}
   * @memberof UploadProjectToEncordPostAction
   */
  dataset_description?: string;
  /**
   *
   * @type {string}
   * @memberof UploadProjectToEncordPostAction
   */
  ontology_title: string;
  /**
   *
   * @type {string}
   * @memberof UploadProjectToEncordPostAction
   */
  ontology_description?: string;
}
/**
 *
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
  /**
   *
   * @type {Array<LocationInner>}
   * @memberof ValidationError
   */
  loc: Array<LocationInner>;
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  msg: string;
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  type: string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary  Favicon Ico
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    faviconIcoFaviconIcoGet: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/favicon.ico`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    healthCheckGet: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary  Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    indexIndexHtmlGet: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/index.html`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Premium Available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    premiumAvailablePremiumAvailableGet: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/premium_available`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary  Favicon Ico
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async faviconIcoFaviconIcoGet(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.faviconIcoFaviconIcoGet(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async healthCheckGet(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.healthCheckGet(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary  Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async indexIndexHtmlGet(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.indexIndexHtmlGet(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Premium Available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async premiumAvailablePremiumAvailableGet(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.premiumAvailablePremiumAvailableGet(
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = DefaultApiFp(configuration);
  return {
    /**
     *
     * @summary  Favicon Ico
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    faviconIcoFaviconIcoGet(options?: any): AxiosPromise<any> {
      return localVarFp
        .faviconIcoFaviconIcoGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    healthCheckGet(options?: any): AxiosPromise<boolean> {
      return localVarFp
        .healthCheckGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary  Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    indexIndexHtmlGet(options?: any): AxiosPromise<any> {
      return localVarFp
        .indexIndexHtmlGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Premium Available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    premiumAvailablePremiumAvailableGet(options?: any): AxiosPromise<boolean> {
      return localVarFp
        .premiumAvailablePremiumAvailableGet(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   *
   * @summary  Favicon Ico
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public faviconIcoFaviconIcoGet(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .faviconIcoFaviconIcoGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Health Check
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public healthCheckGet(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .healthCheckGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary  Index
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public indexIndexHtmlGet(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .indexIndexHtmlGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Premium Available
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public premiumAvailablePremiumAvailableGet(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .premiumAvailablePremiumAvailableGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ProjectsV2Api - axios parameter creator
 * @export
 */
export const ProjectsV2ApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Route Action Create Project Subset
     * @param {string} projectHash
     * @param {CreateProjectSubsetPostAction} createProjectSubsetPostAction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeActionCreateProjectSubsetProjectsV2ProjectHashActionsCreateProjectSubsetPost:
      async (
        projectHash: string,
        createProjectSubsetPostAction: CreateProjectSubsetPostAction,
        options: AxiosRequestConfig = {}
      ): Promise<RequestArgs> => {
        // verify required parameter 'projectHash' is not null or undefined
        assertParamExists(
          "routeActionCreateProjectSubsetProjectsV2ProjectHashActionsCreateProjectSubsetPost",
          "projectHash",
          projectHash
        );
        // verify required parameter 'createProjectSubsetPostAction' is not null or undefined
        assertParamExists(
          "routeActionCreateProjectSubsetProjectsV2ProjectHashActionsCreateProjectSubsetPost",
          "createProjectSubsetPostAction",
          createProjectSubsetPostAction
        );
        const localVarPath =
          `/projects_v2/{project_hash}/actions/create_project_subset`.replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          );
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = {
          method: "POST",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        localVarHeaderParameter["Content-Type"] = "application/json";

        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };
        localVarRequestOptions.data = serializeDataIfNeeded(
          createProjectSubsetPostAction,
          localVarRequestOptions,
          configuration
        );

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        };
      },
    /**
     *
     * @summary Route Action Upload Project To Encord
     * @param {string} projectHash
     * @param {UploadProjectToEncordPostAction} uploadProjectToEncordPostAction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeActionUploadProjectToEncordProjectsV2ProjectHashActionsUploadToEncordPost:
      async (
        projectHash: string,
        uploadProjectToEncordPostAction: UploadProjectToEncordPostAction,
        options: AxiosRequestConfig = {}
      ): Promise<RequestArgs> => {
        // verify required parameter 'projectHash' is not null or undefined
        assertParamExists(
          "routeActionUploadProjectToEncordProjectsV2ProjectHashActionsUploadToEncordPost",
          "projectHash",
          projectHash
        );
        // verify required parameter 'uploadProjectToEncordPostAction' is not null or undefined
        assertParamExists(
          "routeActionUploadProjectToEncordProjectsV2ProjectHashActionsUploadToEncordPost",
          "uploadProjectToEncordPostAction",
          uploadProjectToEncordPostAction
        );
        const localVarPath =
          `/projects_v2/{project_hash}/actions/upload_to_encord`.replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          );
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = {
          method: "POST",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        localVarHeaderParameter["Content-Type"] = "application/json";

        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };
        localVarRequestOptions.data = serializeDataIfNeeded(
          uploadProjectToEncordPostAction,
          localVarRequestOptions,
          configuration
        );

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        };
      },
    /**
     *
     * @summary Route List Projects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeListProjectsProjectsV2Get: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/projects_v2`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Prediction Data Item
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {string} dataItem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionDataItemProjectsV2ProjectHashPredictionsPredictionHashPreviewDataItemGet:
      async (
        projectHash: string,
        predictionHash: string,
        dataItem: string,
        options: AxiosRequestConfig = {}
      ): Promise<RequestArgs> => {
        // verify required parameter 'projectHash' is not null or undefined
        assertParamExists(
          "routePredictionDataItemProjectsV2ProjectHashPredictionsPredictionHashPreviewDataItemGet",
          "projectHash",
          projectHash
        );
        // verify required parameter 'predictionHash' is not null or undefined
        assertParamExists(
          "routePredictionDataItemProjectsV2ProjectHashPredictionsPredictionHashPreviewDataItemGet",
          "predictionHash",
          predictionHash
        );
        // verify required parameter 'dataItem' is not null or undefined
        assertParamExists(
          "routePredictionDataItemProjectsV2ProjectHashPredictionsPredictionHashPreviewDataItemGet",
          "dataItem",
          dataItem
        );
        const localVarPath =
          `/projects_v2/{project_hash}/predictions/{prediction_hash}/preview/{data_item}`
            .replace(
              `{${"project_hash"}}`,
              encodeURIComponent(String(projectHash))
            )
            .replace(
              `{${"prediction_hash"}}`,
              encodeURIComponent(String(predictionHash))
            )
            .replace(`{${"data_item"}}`, encodeURIComponent(String(dataItem)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = {
          method: "GET",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        };
      },
    /**
     *
     * @summary Route Prediction Distribution
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {string} group
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionDistributionProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainDistributionGet:
      async (
        projectHash: string,
        predictionHash: string,
        domain: PredictionDomain,
        iou: number,
        group: string,
        buckets?: AnalysisBuckets,
        filters?: string,
        options: AxiosRequestConfig = {}
      ): Promise<RequestArgs> => {
        // verify required parameter 'projectHash' is not null or undefined
        assertParamExists(
          "routePredictionDistributionProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainDistributionGet",
          "projectHash",
          projectHash
        );
        // verify required parameter 'predictionHash' is not null or undefined
        assertParamExists(
          "routePredictionDistributionProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainDistributionGet",
          "predictionHash",
          predictionHash
        );
        // verify required parameter 'domain' is not null or undefined
        assertParamExists(
          "routePredictionDistributionProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainDistributionGet",
          "domain",
          domain
        );
        // verify required parameter 'iou' is not null or undefined
        assertParamExists(
          "routePredictionDistributionProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainDistributionGet",
          "iou",
          iou
        );
        // verify required parameter 'group' is not null or undefined
        assertParamExists(
          "routePredictionDistributionProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainDistributionGet",
          "group",
          group
        );
        const localVarPath =
          `/projects_v2/{project_hash}/predictions/{prediction_hash}/analytics/{domain}/distribution`
            .replace(
              `{${"project_hash"}}`,
              encodeURIComponent(String(projectHash))
            )
            .replace(
              `{${"prediction_hash"}}`,
              encodeURIComponent(String(predictionHash))
            )
            .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = {
          method: "GET",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        if (iou !== undefined) {
          localVarQueryParameter["iou"] = iou;
        }

        if (group !== undefined) {
          localVarQueryParameter["group"] = group;
        }

        if (buckets !== undefined) {
          localVarQueryParameter["buckets"] = buckets;
        }

        if (filters !== undefined) {
          localVarQueryParameter["filters"] = filters;
        }

        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        };
      },
    /**
     *
     * @summary Route Prediction Metric Performance
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {number} iou
     * @param {string} metricName
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionMetricPerformanceProjectsV2ProjectHashPredictionsPredictionHashMetricPerformanceGet:
      async (
        projectHash: string,
        predictionHash: string,
        iou: number,
        metricName: string,
        buckets?: AnalysisBuckets,
        filters?: string,
        options: AxiosRequestConfig = {}
      ): Promise<RequestArgs> => {
        // verify required parameter 'projectHash' is not null or undefined
        assertParamExists(
          "routePredictionMetricPerformanceProjectsV2ProjectHashPredictionsPredictionHashMetricPerformanceGet",
          "projectHash",
          projectHash
        );
        // verify required parameter 'predictionHash' is not null or undefined
        assertParamExists(
          "routePredictionMetricPerformanceProjectsV2ProjectHashPredictionsPredictionHashMetricPerformanceGet",
          "predictionHash",
          predictionHash
        );
        // verify required parameter 'iou' is not null or undefined
        assertParamExists(
          "routePredictionMetricPerformanceProjectsV2ProjectHashPredictionsPredictionHashMetricPerformanceGet",
          "iou",
          iou
        );
        // verify required parameter 'metricName' is not null or undefined
        assertParamExists(
          "routePredictionMetricPerformanceProjectsV2ProjectHashPredictionsPredictionHashMetricPerformanceGet",
          "metricName",
          metricName
        );
        const localVarPath =
          `/projects_v2/{project_hash}/predictions/{prediction_hash}/metric_performance`
            .replace(
              `{${"project_hash"}}`,
              encodeURIComponent(String(projectHash))
            )
            .replace(
              `{${"prediction_hash"}}`,
              encodeURIComponent(String(predictionHash))
            );
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = {
          method: "GET",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        if (iou !== undefined) {
          localVarQueryParameter["iou"] = iou;
        }

        if (metricName !== undefined) {
          localVarQueryParameter["metric_name"] = metricName;
        }

        if (buckets !== undefined) {
          localVarQueryParameter["buckets"] = buckets;
        }

        if (filters !== undefined) {
          localVarQueryParameter["filters"] = filters;
        }

        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        };
      },
    /**
     *
     * @summary Route Prediction Reduction Scatter
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {string} reductionHash
     * @param {number} iou
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionReductionScatterProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainReductionsReductionHashSummaryGet:
      async (
        projectHash: string,
        predictionHash: string,
        domain: PredictionDomain,
        reductionHash: string,
        iou: number,
        buckets?: AnalysisBuckets,
        filters?: string,
        options: AxiosRequestConfig = {}
      ): Promise<RequestArgs> => {
        // verify required parameter 'projectHash' is not null or undefined
        assertParamExists(
          "routePredictionReductionScatterProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainReductionsReductionHashSummaryGet",
          "projectHash",
          projectHash
        );
        // verify required parameter 'predictionHash' is not null or undefined
        assertParamExists(
          "routePredictionReductionScatterProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainReductionsReductionHashSummaryGet",
          "predictionHash",
          predictionHash
        );
        // verify required parameter 'domain' is not null or undefined
        assertParamExists(
          "routePredictionReductionScatterProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainReductionsReductionHashSummaryGet",
          "domain",
          domain
        );
        // verify required parameter 'reductionHash' is not null or undefined
        assertParamExists(
          "routePredictionReductionScatterProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainReductionsReductionHashSummaryGet",
          "reductionHash",
          reductionHash
        );
        // verify required parameter 'iou' is not null or undefined
        assertParamExists(
          "routePredictionReductionScatterProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainReductionsReductionHashSummaryGet",
          "iou",
          iou
        );
        const localVarPath =
          `/projects_v2/{project_hash}/predictions/{prediction_hash}/analytics/{domain}/reductions/{reduction_hash}/summary`
            .replace(
              `{${"project_hash"}}`,
              encodeURIComponent(String(projectHash))
            )
            .replace(
              `{${"prediction_hash"}}`,
              encodeURIComponent(String(predictionHash))
            )
            .replace(`{${"domain"}}`, encodeURIComponent(String(domain)))
            .replace(
              `{${"reduction_hash"}}`,
              encodeURIComponent(String(reductionHash))
            );
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = {
          method: "GET",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        if (iou !== undefined) {
          localVarQueryParameter["iou"] = iou;
        }

        if (buckets !== undefined) {
          localVarQueryParameter["buckets"] = buckets;
        }

        if (filters !== undefined) {
          localVarQueryParameter["filters"] = filters;
        }

        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        };
      },
    /**
     *
     * @summary Route Prediction Scatter
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {string} xMetric
     * @param {string} yMetric
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionScatterProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainScatterGet:
      async (
        projectHash: string,
        predictionHash: string,
        domain: PredictionDomain,
        iou: number,
        xMetric: string,
        yMetric: string,
        buckets?: AnalysisBuckets,
        filters?: string,
        options: AxiosRequestConfig = {}
      ): Promise<RequestArgs> => {
        // verify required parameter 'projectHash' is not null or undefined
        assertParamExists(
          "routePredictionScatterProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainScatterGet",
          "projectHash",
          projectHash
        );
        // verify required parameter 'predictionHash' is not null or undefined
        assertParamExists(
          "routePredictionScatterProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainScatterGet",
          "predictionHash",
          predictionHash
        );
        // verify required parameter 'domain' is not null or undefined
        assertParamExists(
          "routePredictionScatterProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainScatterGet",
          "domain",
          domain
        );
        // verify required parameter 'iou' is not null or undefined
        assertParamExists(
          "routePredictionScatterProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainScatterGet",
          "iou",
          iou
        );
        // verify required parameter 'xMetric' is not null or undefined
        assertParamExists(
          "routePredictionScatterProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainScatterGet",
          "xMetric",
          xMetric
        );
        // verify required parameter 'yMetric' is not null or undefined
        assertParamExists(
          "routePredictionScatterProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainScatterGet",
          "yMetric",
          yMetric
        );
        const localVarPath =
          `/projects_v2/{project_hash}/predictions/{prediction_hash}/analytics/{domain}/scatter`
            .replace(
              `{${"project_hash"}}`,
              encodeURIComponent(String(projectHash))
            )
            .replace(
              `{${"prediction_hash"}}`,
              encodeURIComponent(String(predictionHash))
            )
            .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = {
          method: "GET",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        if (iou !== undefined) {
          localVarQueryParameter["iou"] = iou;
        }

        if (xMetric !== undefined) {
          localVarQueryParameter["x_metric"] = xMetric;
        }

        if (yMetric !== undefined) {
          localVarQueryParameter["y_metric"] = yMetric;
        }

        if (buckets !== undefined) {
          localVarQueryParameter["buckets"] = buckets;
        }

        if (filters !== undefined) {
          localVarQueryParameter["filters"] = filters;
        }

        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        };
      },
    /**
     *
     * @summary Route Prediction Search
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {string} [orderBy]
     * @param {boolean} [desc]
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionSearchProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainSearchGet:
      async (
        projectHash: string,
        predictionHash: string,
        domain: PredictionDomain,
        iou: number,
        orderBy?: string,
        desc?: boolean,
        offset?: number,
        limit?: number,
        filters?: string,
        options: AxiosRequestConfig = {}
      ): Promise<RequestArgs> => {
        // verify required parameter 'projectHash' is not null or undefined
        assertParamExists(
          "routePredictionSearchProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainSearchGet",
          "projectHash",
          projectHash
        );
        // verify required parameter 'predictionHash' is not null or undefined
        assertParamExists(
          "routePredictionSearchProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainSearchGet",
          "predictionHash",
          predictionHash
        );
        // verify required parameter 'domain' is not null or undefined
        assertParamExists(
          "routePredictionSearchProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainSearchGet",
          "domain",
          domain
        );
        // verify required parameter 'iou' is not null or undefined
        assertParamExists(
          "routePredictionSearchProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainSearchGet",
          "iou",
          iou
        );
        const localVarPath =
          `/projects_v2/{project_hash}/predictions/{prediction_hash}/analytics/{domain}/search`
            .replace(
              `{${"project_hash"}}`,
              encodeURIComponent(String(projectHash))
            )
            .replace(
              `{${"prediction_hash"}}`,
              encodeURIComponent(String(predictionHash))
            )
            .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = {
          method: "GET",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        if (iou !== undefined) {
          localVarQueryParameter["iou"] = iou;
        }

        if (orderBy !== undefined) {
          localVarQueryParameter["order_by"] = orderBy;
        }

        if (desc !== undefined) {
          localVarQueryParameter["desc"] = desc;
        }

        if (offset !== undefined) {
          localVarQueryParameter["offset"] = offset;
        }

        if (limit !== undefined) {
          localVarQueryParameter["limit"] = limit;
        }

        if (filters !== undefined) {
          localVarQueryParameter["filters"] = filters;
        }

        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        };
      },
    /**
     *
     * @summary Route Prediction Summary
     * @param {string} predictionHash
     * @param {string} projectHash
     * @param {number} iou
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionSummaryProjectsV2ProjectHashPredictionsPredictionHashSummaryGet:
      async (
        predictionHash: string,
        projectHash: string,
        iou: number,
        filters?: string,
        options: AxiosRequestConfig = {}
      ): Promise<RequestArgs> => {
        // verify required parameter 'predictionHash' is not null or undefined
        assertParamExists(
          "routePredictionSummaryProjectsV2ProjectHashPredictionsPredictionHashSummaryGet",
          "predictionHash",
          predictionHash
        );
        // verify required parameter 'projectHash' is not null or undefined
        assertParamExists(
          "routePredictionSummaryProjectsV2ProjectHashPredictionsPredictionHashSummaryGet",
          "projectHash",
          projectHash
        );
        // verify required parameter 'iou' is not null or undefined
        assertParamExists(
          "routePredictionSummaryProjectsV2ProjectHashPredictionsPredictionHashSummaryGet",
          "iou",
          iou
        );
        const localVarPath =
          `/projects_v2/{project_hash}/predictions/{prediction_hash}/summary`
            .replace(
              `{${"prediction_hash"}}`,
              encodeURIComponent(String(predictionHash))
            )
            .replace(
              `{${"project_hash"}}`,
              encodeURIComponent(String(projectHash))
            );
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = {
          method: "GET",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        if (iou !== undefined) {
          localVarQueryParameter["iou"] = iou;
        }

        if (filters !== undefined) {
          localVarQueryParameter["filters"] = filters;
        }

        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        };
      },
    /**
     *
     * @summary Route Project Action Tag Items
     * @param {string} projectHash
     * @param {string} tagName
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectActionTagItemsProjectsV2ProjectHashCreateTagPost: async (
      projectHash: string,
      tagName: string,
      requestBody: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routeProjectActionTagItemsProjectsV2ProjectHashCreateTagPost",
        "projectHash",
        projectHash
      );
      // verify required parameter 'tagName' is not null or undefined
      assertParamExists(
        "routeProjectActionTagItemsProjectsV2ProjectHashCreateTagPost",
        "tagName",
        tagName
      );
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists(
        "routeProjectActionTagItemsProjectsV2ProjectHashCreateTagPost",
        "requestBody",
        requestBody
      );
      const localVarPath = `/projects_v2/{project_hash}/create/tag`.replace(
        `{${"project_hash"}}`,
        encodeURIComponent(String(projectHash))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (tagName !== undefined) {
        localVarQueryParameter["tag_name"] = tagName;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Project Compare Metric Dissimilarity
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} compareProjectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectCompareMetricDissimilarityProjectsV2ProjectHashAnalysisDomainProjectCompareMetricDissimilarityGet:
      async (
        projectHash: string,
        domain: AnalysisDomain,
        compareProjectHash: string,
        options: AxiosRequestConfig = {}
      ): Promise<RequestArgs> => {
        // verify required parameter 'projectHash' is not null or undefined
        assertParamExists(
          "routeProjectCompareMetricDissimilarityProjectsV2ProjectHashAnalysisDomainProjectCompareMetricDissimilarityGet",
          "projectHash",
          projectHash
        );
        // verify required parameter 'domain' is not null or undefined
        assertParamExists(
          "routeProjectCompareMetricDissimilarityProjectsV2ProjectHashAnalysisDomainProjectCompareMetricDissimilarityGet",
          "domain",
          domain
        );
        // verify required parameter 'compareProjectHash' is not null or undefined
        assertParamExists(
          "routeProjectCompareMetricDissimilarityProjectsV2ProjectHashAnalysisDomainProjectCompareMetricDissimilarityGet",
          "compareProjectHash",
          compareProjectHash
        );
        const localVarPath =
          `/projects_v2/{project_hash}/analysis/{domain}/project_compare/metric_dissimilarity`
            .replace(
              `{${"project_hash"}}`,
              encodeURIComponent(String(projectHash))
            )
            .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = {
          method: "GET",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        if (compareProjectHash !== undefined) {
          localVarQueryParameter["compare_project_hash"] = compareProjectHash;
        }

        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        };
      },
    /**
     *
     * @summary Route Project Data Item
     * @param {string} projectHash
     * @param {string} dataItem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectDataItemProjectsV2ProjectHashItemDataItemGet: async (
      projectHash: string,
      dataItem: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routeProjectDataItemProjectsV2ProjectHashItemDataItemGet",
        "projectHash",
        projectHash
      );
      // verify required parameter 'dataItem' is not null or undefined
      assertParamExists(
        "routeProjectDataItemProjectsV2ProjectHashItemDataItemGet",
        "dataItem",
        dataItem
      );
      const localVarPath = `/projects_v2/{project_hash}/item/{data_item}/`
        .replace(`{${"project_hash"}}`, encodeURIComponent(String(projectHash)))
        .replace(`{${"data_item"}}`, encodeURIComponent(String(dataItem)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Project Distribution
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} group
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectDistributionProjectsV2ProjectHashAnalysisDomainDistributionGet:
      async (
        projectHash: string,
        domain: AnalysisDomain,
        group: string,
        buckets?: AnalysisBuckets,
        filters?: string,
        options: AxiosRequestConfig = {}
      ): Promise<RequestArgs> => {
        // verify required parameter 'projectHash' is not null or undefined
        assertParamExists(
          "routeProjectDistributionProjectsV2ProjectHashAnalysisDomainDistributionGet",
          "projectHash",
          projectHash
        );
        // verify required parameter 'domain' is not null or undefined
        assertParamExists(
          "routeProjectDistributionProjectsV2ProjectHashAnalysisDomainDistributionGet",
          "domain",
          domain
        );
        // verify required parameter 'group' is not null or undefined
        assertParamExists(
          "routeProjectDistributionProjectsV2ProjectHashAnalysisDomainDistributionGet",
          "group",
          group
        );
        const localVarPath =
          `/projects_v2/{project_hash}/analysis/{domain}/distribution`
            .replace(
              `{${"project_hash"}}`,
              encodeURIComponent(String(projectHash))
            )
            .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = {
          method: "GET",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        if (group !== undefined) {
          localVarQueryParameter["group"] = group;
        }

        if (buckets !== undefined) {
          localVarQueryParameter["buckets"] = buckets;
        }

        if (filters !== undefined) {
          localVarQueryParameter["filters"] = filters;
        }

        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        };
      },
    /**
     *
     * @summary Route Project List Predictions
     * @param {string} projectHash
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {RouteProjectListPredictionsProjectsV2ProjectHashPredictionsGetOrderByEnum} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectListPredictionsProjectsV2ProjectHashPredictionsGet: async (
      projectHash: string,
      offset?: number,
      limit?: number,
      orderBy?: RouteProjectListPredictionsProjectsV2ProjectHashPredictionsGetOrderByEnum,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routeProjectListPredictionsProjectsV2ProjectHashPredictionsGet",
        "projectHash",
        projectHash
      );
      const localVarPath = `/projects_v2/{project_hash}/predictions`.replace(
        `{${"project_hash"}}`,
        encodeURIComponent(String(projectHash))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (orderBy !== undefined) {
        localVarQueryParameter["order_by"] = orderBy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Project List Reductions
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectListReductionsProjectsV2ProjectHashReductionsGet: async (
      projectHash: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routeProjectListReductionsProjectsV2ProjectHashReductionsGet",
        "projectHash",
        projectHash
      );
      const localVarPath = `/projects_v2/{project_hash}/reductions`.replace(
        `{${"project_hash"}}`,
        encodeURIComponent(String(projectHash))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Project Metadata
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectMetadataProjectsV2ProjectHashMetadataGet: async (
      projectHash: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routeProjectMetadataProjectsV2ProjectHashMetadataGet",
        "projectHash",
        projectHash
      );
      const localVarPath = `/projects_v2/{project_hash}/metadata`.replace(
        `{${"project_hash"}}`,
        encodeURIComponent(String(projectHash))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Project Raw File
     * @param {string} projectHash
     * @param {string} duHash
     * @param {number} frame
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectRawFileProjectsV2ProjectHashFilesDuHashFrameGet: async (
      projectHash: string,
      duHash: string,
      frame: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routeProjectRawFileProjectsV2ProjectHashFilesDuHashFrameGet",
        "projectHash",
        projectHash
      );
      // verify required parameter 'duHash' is not null or undefined
      assertParamExists(
        "routeProjectRawFileProjectsV2ProjectHashFilesDuHashFrameGet",
        "duHash",
        duHash
      );
      // verify required parameter 'frame' is not null or undefined
      assertParamExists(
        "routeProjectRawFileProjectsV2ProjectHashFilesDuHashFrameGet",
        "frame",
        frame
      );
      const localVarPath = `/projects_v2/{project_hash}/files/{du_hash}/{frame}`
        .replace(`{${"project_hash"}}`, encodeURIComponent(String(projectHash)))
        .replace(`{${"du_hash"}}`, encodeURIComponent(String(duHash)))
        .replace(`{${"frame"}}`, encodeURIComponent(String(frame)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Project Reduction Scatter
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} reductionHash
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectReductionScatterProjectsV2ProjectHashAnalysisDomainReductionsReductionHashSummaryGet:
      async (
        projectHash: string,
        domain: AnalysisDomain,
        reductionHash: string,
        buckets?: AnalysisBuckets,
        filters?: string,
        options: AxiosRequestConfig = {}
      ): Promise<RequestArgs> => {
        // verify required parameter 'projectHash' is not null or undefined
        assertParamExists(
          "routeProjectReductionScatterProjectsV2ProjectHashAnalysisDomainReductionsReductionHashSummaryGet",
          "projectHash",
          projectHash
        );
        // verify required parameter 'domain' is not null or undefined
        assertParamExists(
          "routeProjectReductionScatterProjectsV2ProjectHashAnalysisDomainReductionsReductionHashSummaryGet",
          "domain",
          domain
        );
        // verify required parameter 'reductionHash' is not null or undefined
        assertParamExists(
          "routeProjectReductionScatterProjectsV2ProjectHashAnalysisDomainReductionsReductionHashSummaryGet",
          "reductionHash",
          reductionHash
        );
        const localVarPath =
          `/projects_v2/{project_hash}/analysis/{domain}/reductions/{reduction_hash}/summary`
            .replace(
              `{${"project_hash"}}`,
              encodeURIComponent(String(projectHash))
            )
            .replace(`{${"domain"}}`, encodeURIComponent(String(domain)))
            .replace(
              `{${"reduction_hash"}}`,
              encodeURIComponent(String(reductionHash))
            );
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = {
          method: "GET",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        if (buckets !== undefined) {
          localVarQueryParameter["buckets"] = buckets;
        }

        if (filters !== undefined) {
          localVarQueryParameter["filters"] = filters;
        }

        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        };
      },
    /**
     *
     * @summary Route Project Scatter
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} xMetric
     * @param {string} yMetric
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectScatterProjectsV2ProjectHashAnalysisDomainScatterGet: async (
      projectHash: string,
      domain: AnalysisDomain,
      xMetric: string,
      yMetric: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routeProjectScatterProjectsV2ProjectHashAnalysisDomainScatterGet",
        "projectHash",
        projectHash
      );
      // verify required parameter 'domain' is not null or undefined
      assertParamExists(
        "routeProjectScatterProjectsV2ProjectHashAnalysisDomainScatterGet",
        "domain",
        domain
      );
      // verify required parameter 'xMetric' is not null or undefined
      assertParamExists(
        "routeProjectScatterProjectsV2ProjectHashAnalysisDomainScatterGet",
        "xMetric",
        xMetric
      );
      // verify required parameter 'yMetric' is not null or undefined
      assertParamExists(
        "routeProjectScatterProjectsV2ProjectHashAnalysisDomainScatterGet",
        "yMetric",
        yMetric
      );
      const localVarPath =
        `/projects_v2/{project_hash}/analysis/{domain}/scatter`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (xMetric !== undefined) {
        localVarQueryParameter["x_metric"] = xMetric;
      }

      if (yMetric !== undefined) {
        localVarQueryParameter["y_metric"] = yMetric;
      }

      if (buckets !== undefined) {
        localVarQueryParameter["buckets"] = buckets;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Project Search
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} [orderBy]
     * @param {boolean} [desc]
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectSearchProjectsV2ProjectHashAnalysisDomainSearchGet: async (
      projectHash: string,
      domain: AnalysisDomain,
      orderBy?: string,
      desc?: boolean,
      offset?: number,
      limit?: number,
      filters?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routeProjectSearchProjectsV2ProjectHashAnalysisDomainSearchGet",
        "projectHash",
        projectHash
      );
      // verify required parameter 'domain' is not null or undefined
      assertParamExists(
        "routeProjectSearchProjectsV2ProjectHashAnalysisDomainSearchGet",
        "domain",
        domain
      );
      const localVarPath =
        `/projects_v2/{project_hash}/analysis/{domain}/search`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (orderBy !== undefined) {
        localVarQueryParameter["order_by"] = orderBy;
      }

      if (desc !== undefined) {
        localVarQueryParameter["desc"] = desc;
      }

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Project Similarity Search
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} item
     * @param {RouteProjectSimilaritySearchProjectsV2ProjectHashAnalysisDomainSimilarityItemGetEmbeddingEnum} embedding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectSimilaritySearchProjectsV2ProjectHashAnalysisDomainSimilarityItemGet:
      async (
        projectHash: string,
        domain: AnalysisDomain,
        item: string,
        embedding: RouteProjectSimilaritySearchProjectsV2ProjectHashAnalysisDomainSimilarityItemGetEmbeddingEnum,
        options: AxiosRequestConfig = {}
      ): Promise<RequestArgs> => {
        // verify required parameter 'projectHash' is not null or undefined
        assertParamExists(
          "routeProjectSimilaritySearchProjectsV2ProjectHashAnalysisDomainSimilarityItemGet",
          "projectHash",
          projectHash
        );
        // verify required parameter 'domain' is not null or undefined
        assertParamExists(
          "routeProjectSimilaritySearchProjectsV2ProjectHashAnalysisDomainSimilarityItemGet",
          "domain",
          domain
        );
        // verify required parameter 'item' is not null or undefined
        assertParamExists(
          "routeProjectSimilaritySearchProjectsV2ProjectHashAnalysisDomainSimilarityItemGet",
          "item",
          item
        );
        // verify required parameter 'embedding' is not null or undefined
        assertParamExists(
          "routeProjectSimilaritySearchProjectsV2ProjectHashAnalysisDomainSimilarityItemGet",
          "embedding",
          embedding
        );
        const localVarPath =
          `/projects_v2/{project_hash}/analysis/{domain}/similarity/{item}`
            .replace(
              `{${"project_hash"}}`,
              encodeURIComponent(String(projectHash))
            )
            .replace(`{${"domain"}}`, encodeURIComponent(String(domain)))
            .replace(`{${"item"}}`, encodeURIComponent(String(item)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = {
          method: "GET",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        if (embedding !== undefined) {
          localVarQueryParameter["embedding"] = embedding;
        }

        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        };
      },
    /**
     *
     * @summary Route Project Summary
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectSummaryProjectsV2ProjectHashAnalysisDomainSummaryGet: async (
      projectHash: string,
      domain: AnalysisDomain,
      filters?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routeProjectSummaryProjectsV2ProjectHashAnalysisDomainSummaryGet",
        "projectHash",
        projectHash
      );
      // verify required parameter 'domain' is not null or undefined
      assertParamExists(
        "routeProjectSummaryProjectsV2ProjectHashAnalysisDomainSummaryGet",
        "domain",
        domain
      );
      const localVarPath =
        `/projects_v2/{project_hash}/analysis/{domain}/summary`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Project Summary
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectSummaryProjectsV2ProjectHashSummaryGet: async (
      projectHash: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routeProjectSummaryProjectsV2ProjectHashSummaryGet",
        "projectHash",
        projectHash
      );
      const localVarPath = `/projects_v2/{project_hash}/summary`.replace(
        `{${"project_hash"}}`,
        encodeURIComponent(String(projectHash))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProjectsV2Api - functional programming interface
 * @export
 */
export const ProjectsV2ApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ProjectsV2ApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Route Action Create Project Subset
     * @param {string} projectHash
     * @param {CreateProjectSubsetPostAction} createProjectSubsetPostAction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeActionCreateProjectSubsetProjectsV2ProjectHashActionsCreateProjectSubsetPost(
      projectHash: string,
      createProjectSubsetPostAction: CreateProjectSubsetPostAction,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeActionCreateProjectSubsetProjectsV2ProjectHashActionsCreateProjectSubsetPost(
          projectHash,
          createProjectSubsetPostAction,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Action Upload Project To Encord
     * @param {string} projectHash
     * @param {UploadProjectToEncordPostAction} uploadProjectToEncordPostAction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeActionUploadProjectToEncordProjectsV2ProjectHashActionsUploadToEncordPost(
      projectHash: string,
      uploadProjectToEncordPostAction: UploadProjectToEncordPostAction,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeActionUploadProjectToEncordProjectsV2ProjectHashActionsUploadToEncordPost(
          projectHash,
          uploadProjectToEncordPostAction,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route List Projects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeListProjectsProjectsV2Get(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ProjectSearchResult>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeListProjectsProjectsV2Get(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Prediction Data Item
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {string} dataItem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routePredictionDataItemProjectsV2ProjectHashPredictionsPredictionHashPreviewDataItemGet(
      projectHash: string,
      predictionHash: string,
      dataItem: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PredictionItem>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routePredictionDataItemProjectsV2ProjectHashPredictionsPredictionHashPreviewDataItemGet(
          projectHash,
          predictionHash,
          dataItem,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Prediction Distribution
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {string} group
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routePredictionDistributionProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainDistributionGet(
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      group: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<QueryDistribution>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routePredictionDistributionProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainDistributionGet(
          projectHash,
          predictionHash,
          domain,
          iou,
          group,
          buckets,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Prediction Metric Performance
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {number} iou
     * @param {string} metricName
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routePredictionMetricPerformanceProjectsV2ProjectHashPredictionsPredictionHashMetricPerformanceGet(
      projectHash: string,
      predictionHash: string,
      iou: number,
      metricName: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<QueryMetricPerformance>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routePredictionMetricPerformanceProjectsV2ProjectHashPredictionsPredictionHashMetricPerformanceGet(
          projectHash,
          predictionHash,
          iou,
          metricName,
          buckets,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Prediction Reduction Scatter
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {string} reductionHash
     * @param {number} iou
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routePredictionReductionScatterProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainReductionsReductionHashSummaryGet(
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      reductionHash: string,
      iou: number,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PredictionQuery2DEmbedding>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routePredictionReductionScatterProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainReductionsReductionHashSummaryGet(
          projectHash,
          predictionHash,
          domain,
          reductionHash,
          iou,
          buckets,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Prediction Scatter
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {string} xMetric
     * @param {string} yMetric
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routePredictionScatterProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainScatterGet(
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      xMetric: string,
      yMetric: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryScatter>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routePredictionScatterProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainScatterGet(
          projectHash,
          predictionHash,
          domain,
          iou,
          xMetric,
          yMetric,
          buckets,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Prediction Search
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {string} [orderBy]
     * @param {boolean} [desc]
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routePredictionSearchProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainSearchGet(
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      orderBy?: string,
      desc?: boolean,
      offset?: number,
      limit?: number,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalysisSearch>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routePredictionSearchProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainSearchGet(
          projectHash,
          predictionHash,
          domain,
          iou,
          orderBy,
          desc,
          offset,
          limit,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Prediction Summary
     * @param {string} predictionHash
     * @param {string} projectHash
     * @param {number} iou
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routePredictionSummaryProjectsV2ProjectHashPredictionsPredictionHashSummaryGet(
      predictionHash: string,
      projectHash: string,
      iou: number,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PredictionSummaryResult>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routePredictionSummaryProjectsV2ProjectHashPredictionsPredictionHashSummaryGet(
          predictionHash,
          projectHash,
          iou,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Action Tag Items
     * @param {string} projectHash
     * @param {string} tagName
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectActionTagItemsProjectsV2ProjectHashCreateTagPost(
      projectHash: string,
      tagName: string,
      requestBody: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectActionTagItemsProjectsV2ProjectHashCreateTagPost(
          projectHash,
          tagName,
          requestBody,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Compare Metric Dissimilarity
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} compareProjectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectCompareMetricDissimilarityProjectsV2ProjectHashAnalysisDomainProjectCompareMetricDissimilarityGet(
      projectHash: string,
      domain: AnalysisDomain,
      compareProjectHash: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MetricDissimilarityResult>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectCompareMetricDissimilarityProjectsV2ProjectHashAnalysisDomainProjectCompareMetricDissimilarityGet(
          projectHash,
          domain,
          compareProjectHash,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Data Item
     * @param {string} projectHash
     * @param {string} dataItem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectDataItemProjectsV2ProjectHashItemDataItemGet(
      projectHash: string,
      dataItem: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectItem>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectDataItemProjectsV2ProjectHashItemDataItemGet(
          projectHash,
          dataItem,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Distribution
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} group
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectDistributionProjectsV2ProjectHashAnalysisDomainDistributionGet(
      projectHash: string,
      domain: AnalysisDomain,
      group: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<QueryDistribution>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectDistributionProjectsV2ProjectHashAnalysisDomainDistributionGet(
          projectHash,
          domain,
          group,
          buckets,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project List Predictions
     * @param {string} projectHash
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {RouteProjectListPredictionsProjectsV2ProjectHashPredictionsGetOrderByEnum} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectListPredictionsProjectsV2ProjectHashPredictionsGet(
      projectHash: string,
      offset?: number,
      limit?: number,
      orderBy?: RouteProjectListPredictionsProjectsV2ProjectHashPredictionsGetOrderByEnum,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListProjectPredictionResult>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectListPredictionsProjectsV2ProjectHashPredictionsGet(
          projectHash,
          offset,
          limit,
          orderBy,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project List Reductions
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectListReductionsProjectsV2ProjectHashReductionsGet(
      projectHash: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ProjectList2DEmbeddingReductionResult>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectListReductionsProjectsV2ProjectHashReductionsGet(
          projectHash,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Metadata
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectMetadataProjectsV2ProjectHashMetadataGet(
      projectHash: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ProjectMetadata>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectMetadataProjectsV2ProjectHashMetadataGet(
          projectHash,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Raw File
     * @param {string} projectHash
     * @param {string} duHash
     * @param {number} frame
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectRawFileProjectsV2ProjectHashFilesDuHashFrameGet(
      projectHash: string,
      duHash: string,
      frame: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectRawFileProjectsV2ProjectHashFilesDuHashFrameGet(
          projectHash,
          duHash,
          frame,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Reduction Scatter
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} reductionHash
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectReductionScatterProjectsV2ProjectHashAnalysisDomainReductionsReductionHashSummaryGet(
      projectHash: string,
      domain: AnalysisDomain,
      reductionHash: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Query2DEmbedding>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectReductionScatterProjectsV2ProjectHashAnalysisDomainReductionsReductionHashSummaryGet(
          projectHash,
          domain,
          reductionHash,
          buckets,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Scatter
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} xMetric
     * @param {string} yMetric
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectScatterProjectsV2ProjectHashAnalysisDomainScatterGet(
      projectHash: string,
      domain: AnalysisDomain,
      xMetric: string,
      yMetric: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryScatter>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectScatterProjectsV2ProjectHashAnalysisDomainScatterGet(
          projectHash,
          domain,
          xMetric,
          yMetric,
          buckets,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Search
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} [orderBy]
     * @param {boolean} [desc]
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectSearchProjectsV2ProjectHashAnalysisDomainSearchGet(
      projectHash: string,
      domain: AnalysisDomain,
      orderBy?: string,
      desc?: boolean,
      offset?: number,
      limit?: number,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalysisSearch>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectSearchProjectsV2ProjectHashAnalysisDomainSearchGet(
          projectHash,
          domain,
          orderBy,
          desc,
          offset,
          limit,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Similarity Search
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} item
     * @param {RouteProjectSimilaritySearchProjectsV2ProjectHashAnalysisDomainSimilarityItemGetEmbeddingEnum} embedding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectSimilaritySearchProjectsV2ProjectHashAnalysisDomainSimilarityItemGet(
      projectHash: string,
      domain: AnalysisDomain,
      item: string,
      embedding: RouteProjectSimilaritySearchProjectsV2ProjectHashAnalysisDomainSimilarityItemGetEmbeddingEnum,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<SimilarityResult>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectSimilaritySearchProjectsV2ProjectHashAnalysisDomainSimilarityItemGet(
          projectHash,
          domain,
          item,
          embedding,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Summary
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectSummaryProjectsV2ProjectHashAnalysisDomainSummaryGet(
      projectHash: string,
      domain: AnalysisDomain,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuerySummary>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectSummaryProjectsV2ProjectHashAnalysisDomainSummaryGet(
          projectHash,
          domain,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Summary
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectSummaryProjectsV2ProjectHashSummaryGet(
      projectHash: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectSummary>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectSummaryProjectsV2ProjectHashSummaryGet(
          projectHash,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ProjectsV2Api - factory interface
 * @export
 */
export const ProjectsV2ApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ProjectsV2ApiFp(configuration);
  return {
    /**
     *
     * @summary Route Action Create Project Subset
     * @param {string} projectHash
     * @param {CreateProjectSubsetPostAction} createProjectSubsetPostAction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeActionCreateProjectSubsetProjectsV2ProjectHashActionsCreateProjectSubsetPost(
      projectHash: string,
      createProjectSubsetPostAction: CreateProjectSubsetPostAction,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .routeActionCreateProjectSubsetProjectsV2ProjectHashActionsCreateProjectSubsetPost(
          projectHash,
          createProjectSubsetPostAction,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Action Upload Project To Encord
     * @param {string} projectHash
     * @param {UploadProjectToEncordPostAction} uploadProjectToEncordPostAction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeActionUploadProjectToEncordProjectsV2ProjectHashActionsUploadToEncordPost(
      projectHash: string,
      uploadProjectToEncordPostAction: UploadProjectToEncordPostAction,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .routeActionUploadProjectToEncordProjectsV2ProjectHashActionsUploadToEncordPost(
          projectHash,
          uploadProjectToEncordPostAction,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route List Projects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeListProjectsProjectsV2Get(
      options?: any
    ): AxiosPromise<ProjectSearchResult> {
      return localVarFp
        .routeListProjectsProjectsV2Get(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Prediction Data Item
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {string} dataItem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionDataItemProjectsV2ProjectHashPredictionsPredictionHashPreviewDataItemGet(
      projectHash: string,
      predictionHash: string,
      dataItem: string,
      options?: any
    ): AxiosPromise<PredictionItem> {
      return localVarFp
        .routePredictionDataItemProjectsV2ProjectHashPredictionsPredictionHashPreviewDataItemGet(
          projectHash,
          predictionHash,
          dataItem,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Prediction Distribution
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {string} group
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionDistributionProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainDistributionGet(
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      group: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: any
    ): AxiosPromise<QueryDistribution> {
      return localVarFp
        .routePredictionDistributionProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainDistributionGet(
          projectHash,
          predictionHash,
          domain,
          iou,
          group,
          buckets,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Prediction Metric Performance
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {number} iou
     * @param {string} metricName
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionMetricPerformanceProjectsV2ProjectHashPredictionsPredictionHashMetricPerformanceGet(
      projectHash: string,
      predictionHash: string,
      iou: number,
      metricName: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: any
    ): AxiosPromise<QueryMetricPerformance> {
      return localVarFp
        .routePredictionMetricPerformanceProjectsV2ProjectHashPredictionsPredictionHashMetricPerformanceGet(
          projectHash,
          predictionHash,
          iou,
          metricName,
          buckets,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Prediction Reduction Scatter
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {string} reductionHash
     * @param {number} iou
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionReductionScatterProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainReductionsReductionHashSummaryGet(
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      reductionHash: string,
      iou: number,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: any
    ): AxiosPromise<PredictionQuery2DEmbedding> {
      return localVarFp
        .routePredictionReductionScatterProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainReductionsReductionHashSummaryGet(
          projectHash,
          predictionHash,
          domain,
          reductionHash,
          iou,
          buckets,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Prediction Scatter
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {string} xMetric
     * @param {string} yMetric
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionScatterProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainScatterGet(
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      xMetric: string,
      yMetric: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: any
    ): AxiosPromise<QueryScatter> {
      return localVarFp
        .routePredictionScatterProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainScatterGet(
          projectHash,
          predictionHash,
          domain,
          iou,
          xMetric,
          yMetric,
          buckets,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Prediction Search
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {string} [orderBy]
     * @param {boolean} [desc]
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionSearchProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainSearchGet(
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      orderBy?: string,
      desc?: boolean,
      offset?: number,
      limit?: number,
      filters?: string,
      options?: any
    ): AxiosPromise<AnalysisSearch> {
      return localVarFp
        .routePredictionSearchProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainSearchGet(
          projectHash,
          predictionHash,
          domain,
          iou,
          orderBy,
          desc,
          offset,
          limit,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Prediction Summary
     * @param {string} predictionHash
     * @param {string} projectHash
     * @param {number} iou
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionSummaryProjectsV2ProjectHashPredictionsPredictionHashSummaryGet(
      predictionHash: string,
      projectHash: string,
      iou: number,
      filters?: string,
      options?: any
    ): AxiosPromise<PredictionSummaryResult> {
      return localVarFp
        .routePredictionSummaryProjectsV2ProjectHashPredictionsPredictionHashSummaryGet(
          predictionHash,
          projectHash,
          iou,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Action Tag Items
     * @param {string} projectHash
     * @param {string} tagName
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectActionTagItemsProjectsV2ProjectHashCreateTagPost(
      projectHash: string,
      tagName: string,
      requestBody: Array<string>,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .routeProjectActionTagItemsProjectsV2ProjectHashCreateTagPost(
          projectHash,
          tagName,
          requestBody,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Compare Metric Dissimilarity
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} compareProjectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectCompareMetricDissimilarityProjectsV2ProjectHashAnalysisDomainProjectCompareMetricDissimilarityGet(
      projectHash: string,
      domain: AnalysisDomain,
      compareProjectHash: string,
      options?: any
    ): AxiosPromise<MetricDissimilarityResult> {
      return localVarFp
        .routeProjectCompareMetricDissimilarityProjectsV2ProjectHashAnalysisDomainProjectCompareMetricDissimilarityGet(
          projectHash,
          domain,
          compareProjectHash,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Data Item
     * @param {string} projectHash
     * @param {string} dataItem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectDataItemProjectsV2ProjectHashItemDataItemGet(
      projectHash: string,
      dataItem: string,
      options?: any
    ): AxiosPromise<ProjectItem> {
      return localVarFp
        .routeProjectDataItemProjectsV2ProjectHashItemDataItemGet(
          projectHash,
          dataItem,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Distribution
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} group
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectDistributionProjectsV2ProjectHashAnalysisDomainDistributionGet(
      projectHash: string,
      domain: AnalysisDomain,
      group: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: any
    ): AxiosPromise<QueryDistribution> {
      return localVarFp
        .routeProjectDistributionProjectsV2ProjectHashAnalysisDomainDistributionGet(
          projectHash,
          domain,
          group,
          buckets,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project List Predictions
     * @param {string} projectHash
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {RouteProjectListPredictionsProjectsV2ProjectHashPredictionsGetOrderByEnum} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectListPredictionsProjectsV2ProjectHashPredictionsGet(
      projectHash: string,
      offset?: number,
      limit?: number,
      orderBy?: RouteProjectListPredictionsProjectsV2ProjectHashPredictionsGetOrderByEnum,
      options?: any
    ): AxiosPromise<ListProjectPredictionResult> {
      return localVarFp
        .routeProjectListPredictionsProjectsV2ProjectHashPredictionsGet(
          projectHash,
          offset,
          limit,
          orderBy,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project List Reductions
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectListReductionsProjectsV2ProjectHashReductionsGet(
      projectHash: string,
      options?: any
    ): AxiosPromise<ProjectList2DEmbeddingReductionResult> {
      return localVarFp
        .routeProjectListReductionsProjectsV2ProjectHashReductionsGet(
          projectHash,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Metadata
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectMetadataProjectsV2ProjectHashMetadataGet(
      projectHash: string,
      options?: any
    ): AxiosPromise<ProjectMetadata> {
      return localVarFp
        .routeProjectMetadataProjectsV2ProjectHashMetadataGet(
          projectHash,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Raw File
     * @param {string} projectHash
     * @param {string} duHash
     * @param {number} frame
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectRawFileProjectsV2ProjectHashFilesDuHashFrameGet(
      projectHash: string,
      duHash: string,
      frame: number,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .routeProjectRawFileProjectsV2ProjectHashFilesDuHashFrameGet(
          projectHash,
          duHash,
          frame,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Reduction Scatter
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} reductionHash
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectReductionScatterProjectsV2ProjectHashAnalysisDomainReductionsReductionHashSummaryGet(
      projectHash: string,
      domain: AnalysisDomain,
      reductionHash: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: any
    ): AxiosPromise<Query2DEmbedding> {
      return localVarFp
        .routeProjectReductionScatterProjectsV2ProjectHashAnalysisDomainReductionsReductionHashSummaryGet(
          projectHash,
          domain,
          reductionHash,
          buckets,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Scatter
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} xMetric
     * @param {string} yMetric
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectScatterProjectsV2ProjectHashAnalysisDomainScatterGet(
      projectHash: string,
      domain: AnalysisDomain,
      xMetric: string,
      yMetric: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: any
    ): AxiosPromise<QueryScatter> {
      return localVarFp
        .routeProjectScatterProjectsV2ProjectHashAnalysisDomainScatterGet(
          projectHash,
          domain,
          xMetric,
          yMetric,
          buckets,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Search
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} [orderBy]
     * @param {boolean} [desc]
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectSearchProjectsV2ProjectHashAnalysisDomainSearchGet(
      projectHash: string,
      domain: AnalysisDomain,
      orderBy?: string,
      desc?: boolean,
      offset?: number,
      limit?: number,
      filters?: string,
      options?: any
    ): AxiosPromise<AnalysisSearch> {
      return localVarFp
        .routeProjectSearchProjectsV2ProjectHashAnalysisDomainSearchGet(
          projectHash,
          domain,
          orderBy,
          desc,
          offset,
          limit,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Similarity Search
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} item
     * @param {RouteProjectSimilaritySearchProjectsV2ProjectHashAnalysisDomainSimilarityItemGetEmbeddingEnum} embedding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectSimilaritySearchProjectsV2ProjectHashAnalysisDomainSimilarityItemGet(
      projectHash: string,
      domain: AnalysisDomain,
      item: string,
      embedding: RouteProjectSimilaritySearchProjectsV2ProjectHashAnalysisDomainSimilarityItemGetEmbeddingEnum,
      options?: any
    ): AxiosPromise<Array<SimilarityResult>> {
      return localVarFp
        .routeProjectSimilaritySearchProjectsV2ProjectHashAnalysisDomainSimilarityItemGet(
          projectHash,
          domain,
          item,
          embedding,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Summary
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectSummaryProjectsV2ProjectHashAnalysisDomainSummaryGet(
      projectHash: string,
      domain: AnalysisDomain,
      filters?: string,
      options?: any
    ): AxiosPromise<QuerySummary> {
      return localVarFp
        .routeProjectSummaryProjectsV2ProjectHashAnalysisDomainSummaryGet(
          projectHash,
          domain,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Summary
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectSummaryProjectsV2ProjectHashSummaryGet(
      projectHash: string,
      options?: any
    ): AxiosPromise<ProjectSummary> {
      return localVarFp
        .routeProjectSummaryProjectsV2ProjectHashSummaryGet(
          projectHash,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ProjectsV2Api - object-oriented interface
 * @export
 * @class ProjectsV2Api
 * @extends {BaseAPI}
 */
export class ProjectsV2Api extends BaseAPI {
  /**
   *
   * @summary Route Action Create Project Subset
   * @param {string} projectHash
   * @param {CreateProjectSubsetPostAction} createProjectSubsetPostAction
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsV2Api
   */
  public routeActionCreateProjectSubsetProjectsV2ProjectHashActionsCreateProjectSubsetPost(
    projectHash: string,
    createProjectSubsetPostAction: CreateProjectSubsetPostAction,
    options?: AxiosRequestConfig
  ) {
    return ProjectsV2ApiFp(this.configuration)
      .routeActionCreateProjectSubsetProjectsV2ProjectHashActionsCreateProjectSubsetPost(
        projectHash,
        createProjectSubsetPostAction,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Action Upload Project To Encord
   * @param {string} projectHash
   * @param {UploadProjectToEncordPostAction} uploadProjectToEncordPostAction
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsV2Api
   */
  public routeActionUploadProjectToEncordProjectsV2ProjectHashActionsUploadToEncordPost(
    projectHash: string,
    uploadProjectToEncordPostAction: UploadProjectToEncordPostAction,
    options?: AxiosRequestConfig
  ) {
    return ProjectsV2ApiFp(this.configuration)
      .routeActionUploadProjectToEncordProjectsV2ProjectHashActionsUploadToEncordPost(
        projectHash,
        uploadProjectToEncordPostAction,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route List Projects
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsV2Api
   */
  public routeListProjectsProjectsV2Get(options?: AxiosRequestConfig) {
    return ProjectsV2ApiFp(this.configuration)
      .routeListProjectsProjectsV2Get(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Prediction Data Item
   * @param {string} projectHash
   * @param {string} predictionHash
   * @param {string} dataItem
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsV2Api
   */
  public routePredictionDataItemProjectsV2ProjectHashPredictionsPredictionHashPreviewDataItemGet(
    projectHash: string,
    predictionHash: string,
    dataItem: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectsV2ApiFp(this.configuration)
      .routePredictionDataItemProjectsV2ProjectHashPredictionsPredictionHashPreviewDataItemGet(
        projectHash,
        predictionHash,
        dataItem,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Prediction Distribution
   * @param {string} projectHash
   * @param {string} predictionHash
   * @param {PredictionDomain} domain
   * @param {number} iou
   * @param {string} group
   * @param {AnalysisBuckets} [buckets]
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsV2Api
   */
  public routePredictionDistributionProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainDistributionGet(
    projectHash: string,
    predictionHash: string,
    domain: PredictionDomain,
    iou: number,
    group: string,
    buckets?: AnalysisBuckets,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectsV2ApiFp(this.configuration)
      .routePredictionDistributionProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainDistributionGet(
        projectHash,
        predictionHash,
        domain,
        iou,
        group,
        buckets,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Prediction Metric Performance
   * @param {string} projectHash
   * @param {string} predictionHash
   * @param {number} iou
   * @param {string} metricName
   * @param {AnalysisBuckets} [buckets]
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsV2Api
   */
  public routePredictionMetricPerformanceProjectsV2ProjectHashPredictionsPredictionHashMetricPerformanceGet(
    projectHash: string,
    predictionHash: string,
    iou: number,
    metricName: string,
    buckets?: AnalysisBuckets,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectsV2ApiFp(this.configuration)
      .routePredictionMetricPerformanceProjectsV2ProjectHashPredictionsPredictionHashMetricPerformanceGet(
        projectHash,
        predictionHash,
        iou,
        metricName,
        buckets,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Prediction Reduction Scatter
   * @param {string} projectHash
   * @param {string} predictionHash
   * @param {PredictionDomain} domain
   * @param {string} reductionHash
   * @param {number} iou
   * @param {AnalysisBuckets} [buckets]
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsV2Api
   */
  public routePredictionReductionScatterProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainReductionsReductionHashSummaryGet(
    projectHash: string,
    predictionHash: string,
    domain: PredictionDomain,
    reductionHash: string,
    iou: number,
    buckets?: AnalysisBuckets,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectsV2ApiFp(this.configuration)
      .routePredictionReductionScatterProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainReductionsReductionHashSummaryGet(
        projectHash,
        predictionHash,
        domain,
        reductionHash,
        iou,
        buckets,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Prediction Scatter
   * @param {string} projectHash
   * @param {string} predictionHash
   * @param {PredictionDomain} domain
   * @param {number} iou
   * @param {string} xMetric
   * @param {string} yMetric
   * @param {AnalysisBuckets} [buckets]
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsV2Api
   */
  public routePredictionScatterProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainScatterGet(
    projectHash: string,
    predictionHash: string,
    domain: PredictionDomain,
    iou: number,
    xMetric: string,
    yMetric: string,
    buckets?: AnalysisBuckets,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectsV2ApiFp(this.configuration)
      .routePredictionScatterProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainScatterGet(
        projectHash,
        predictionHash,
        domain,
        iou,
        xMetric,
        yMetric,
        buckets,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Prediction Search
   * @param {string} projectHash
   * @param {string} predictionHash
   * @param {PredictionDomain} domain
   * @param {number} iou
   * @param {string} [orderBy]
   * @param {boolean} [desc]
   * @param {number} [offset]
   * @param {number} [limit]
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsV2Api
   */
  public routePredictionSearchProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainSearchGet(
    projectHash: string,
    predictionHash: string,
    domain: PredictionDomain,
    iou: number,
    orderBy?: string,
    desc?: boolean,
    offset?: number,
    limit?: number,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectsV2ApiFp(this.configuration)
      .routePredictionSearchProjectsV2ProjectHashPredictionsPredictionHashAnalyticsDomainSearchGet(
        projectHash,
        predictionHash,
        domain,
        iou,
        orderBy,
        desc,
        offset,
        limit,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Prediction Summary
   * @param {string} predictionHash
   * @param {string} projectHash
   * @param {number} iou
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsV2Api
   */
  public routePredictionSummaryProjectsV2ProjectHashPredictionsPredictionHashSummaryGet(
    predictionHash: string,
    projectHash: string,
    iou: number,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectsV2ApiFp(this.configuration)
      .routePredictionSummaryProjectsV2ProjectHashPredictionsPredictionHashSummaryGet(
        predictionHash,
        projectHash,
        iou,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Action Tag Items
   * @param {string} projectHash
   * @param {string} tagName
   * @param {Array<string>} requestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsV2Api
   */
  public routeProjectActionTagItemsProjectsV2ProjectHashCreateTagPost(
    projectHash: string,
    tagName: string,
    requestBody: Array<string>,
    options?: AxiosRequestConfig
  ) {
    return ProjectsV2ApiFp(this.configuration)
      .routeProjectActionTagItemsProjectsV2ProjectHashCreateTagPost(
        projectHash,
        tagName,
        requestBody,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Compare Metric Dissimilarity
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {string} compareProjectHash
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsV2Api
   */
  public routeProjectCompareMetricDissimilarityProjectsV2ProjectHashAnalysisDomainProjectCompareMetricDissimilarityGet(
    projectHash: string,
    domain: AnalysisDomain,
    compareProjectHash: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectsV2ApiFp(this.configuration)
      .routeProjectCompareMetricDissimilarityProjectsV2ProjectHashAnalysisDomainProjectCompareMetricDissimilarityGet(
        projectHash,
        domain,
        compareProjectHash,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Data Item
   * @param {string} projectHash
   * @param {string} dataItem
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsV2Api
   */
  public routeProjectDataItemProjectsV2ProjectHashItemDataItemGet(
    projectHash: string,
    dataItem: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectsV2ApiFp(this.configuration)
      .routeProjectDataItemProjectsV2ProjectHashItemDataItemGet(
        projectHash,
        dataItem,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Distribution
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {string} group
   * @param {AnalysisBuckets} [buckets]
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsV2Api
   */
  public routeProjectDistributionProjectsV2ProjectHashAnalysisDomainDistributionGet(
    projectHash: string,
    domain: AnalysisDomain,
    group: string,
    buckets?: AnalysisBuckets,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectsV2ApiFp(this.configuration)
      .routeProjectDistributionProjectsV2ProjectHashAnalysisDomainDistributionGet(
        projectHash,
        domain,
        group,
        buckets,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project List Predictions
   * @param {string} projectHash
   * @param {number} [offset]
   * @param {number} [limit]
   * @param {RouteProjectListPredictionsProjectsV2ProjectHashPredictionsGetOrderByEnum} [orderBy]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsV2Api
   */
  public routeProjectListPredictionsProjectsV2ProjectHashPredictionsGet(
    projectHash: string,
    offset?: number,
    limit?: number,
    orderBy?: RouteProjectListPredictionsProjectsV2ProjectHashPredictionsGetOrderByEnum,
    options?: AxiosRequestConfig
  ) {
    return ProjectsV2ApiFp(this.configuration)
      .routeProjectListPredictionsProjectsV2ProjectHashPredictionsGet(
        projectHash,
        offset,
        limit,
        orderBy,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project List Reductions
   * @param {string} projectHash
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsV2Api
   */
  public routeProjectListReductionsProjectsV2ProjectHashReductionsGet(
    projectHash: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectsV2ApiFp(this.configuration)
      .routeProjectListReductionsProjectsV2ProjectHashReductionsGet(
        projectHash,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Metadata
   * @param {string} projectHash
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsV2Api
   */
  public routeProjectMetadataProjectsV2ProjectHashMetadataGet(
    projectHash: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectsV2ApiFp(this.configuration)
      .routeProjectMetadataProjectsV2ProjectHashMetadataGet(
        projectHash,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Raw File
   * @param {string} projectHash
   * @param {string} duHash
   * @param {number} frame
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsV2Api
   */
  public routeProjectRawFileProjectsV2ProjectHashFilesDuHashFrameGet(
    projectHash: string,
    duHash: string,
    frame: number,
    options?: AxiosRequestConfig
  ) {
    return ProjectsV2ApiFp(this.configuration)
      .routeProjectRawFileProjectsV2ProjectHashFilesDuHashFrameGet(
        projectHash,
        duHash,
        frame,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Reduction Scatter
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {string} reductionHash
   * @param {AnalysisBuckets} [buckets]
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsV2Api
   */
  public routeProjectReductionScatterProjectsV2ProjectHashAnalysisDomainReductionsReductionHashSummaryGet(
    projectHash: string,
    domain: AnalysisDomain,
    reductionHash: string,
    buckets?: AnalysisBuckets,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectsV2ApiFp(this.configuration)
      .routeProjectReductionScatterProjectsV2ProjectHashAnalysisDomainReductionsReductionHashSummaryGet(
        projectHash,
        domain,
        reductionHash,
        buckets,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Scatter
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {string} xMetric
   * @param {string} yMetric
   * @param {AnalysisBuckets} [buckets]
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsV2Api
   */
  public routeProjectScatterProjectsV2ProjectHashAnalysisDomainScatterGet(
    projectHash: string,
    domain: AnalysisDomain,
    xMetric: string,
    yMetric: string,
    buckets?: AnalysisBuckets,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectsV2ApiFp(this.configuration)
      .routeProjectScatterProjectsV2ProjectHashAnalysisDomainScatterGet(
        projectHash,
        domain,
        xMetric,
        yMetric,
        buckets,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Search
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {string} [orderBy]
   * @param {boolean} [desc]
   * @param {number} [offset]
   * @param {number} [limit]
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsV2Api
   */
  public routeProjectSearchProjectsV2ProjectHashAnalysisDomainSearchGet(
    projectHash: string,
    domain: AnalysisDomain,
    orderBy?: string,
    desc?: boolean,
    offset?: number,
    limit?: number,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectsV2ApiFp(this.configuration)
      .routeProjectSearchProjectsV2ProjectHashAnalysisDomainSearchGet(
        projectHash,
        domain,
        orderBy,
        desc,
        offset,
        limit,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Similarity Search
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {string} item
   * @param {RouteProjectSimilaritySearchProjectsV2ProjectHashAnalysisDomainSimilarityItemGetEmbeddingEnum} embedding
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsV2Api
   */
  public routeProjectSimilaritySearchProjectsV2ProjectHashAnalysisDomainSimilarityItemGet(
    projectHash: string,
    domain: AnalysisDomain,
    item: string,
    embedding: RouteProjectSimilaritySearchProjectsV2ProjectHashAnalysisDomainSimilarityItemGetEmbeddingEnum,
    options?: AxiosRequestConfig
  ) {
    return ProjectsV2ApiFp(this.configuration)
      .routeProjectSimilaritySearchProjectsV2ProjectHashAnalysisDomainSimilarityItemGet(
        projectHash,
        domain,
        item,
        embedding,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Summary
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsV2Api
   */
  public routeProjectSummaryProjectsV2ProjectHashAnalysisDomainSummaryGet(
    projectHash: string,
    domain: AnalysisDomain,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectsV2ApiFp(this.configuration)
      .routeProjectSummaryProjectsV2ProjectHashAnalysisDomainSummaryGet(
        projectHash,
        domain,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Summary
   * @param {string} projectHash
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsV2Api
   */
  public routeProjectSummaryProjectsV2ProjectHashSummaryGet(
    projectHash: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectsV2ApiFp(this.configuration)
      .routeProjectSummaryProjectsV2ProjectHashSummaryGet(projectHash, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const RouteProjectListPredictionsProjectsV2ProjectHashPredictionsGetOrderByEnum =
  {
    Empty: "",
  } as const;
export type RouteProjectListPredictionsProjectsV2ProjectHashPredictionsGetOrderByEnum =
  (typeof RouteProjectListPredictionsProjectsV2ProjectHashPredictionsGetOrderByEnum)[keyof typeof RouteProjectListPredictionsProjectsV2ProjectHashPredictionsGetOrderByEnum];
/**
 * @export
 */
export const RouteProjectSimilaritySearchProjectsV2ProjectHashAnalysisDomainSimilarityItemGetEmbeddingEnum =
  {
    EmbeddingClip: "embedding_clip",
  } as const;
export type RouteProjectSimilaritySearchProjectsV2ProjectHashAnalysisDomainSimilarityItemGetEmbeddingEnum =
  (typeof RouteProjectSimilaritySearchProjectsV2ProjectHashAnalysisDomainSimilarityItemGetEmbeddingEnum)[keyof typeof RouteProjectSimilaritySearchProjectsV2ProjectHashAnalysisDomainSimilarityItemGetEmbeddingEnum];
