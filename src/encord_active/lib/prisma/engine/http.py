# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

import datetime
import decimal
import sys

# global imports for type checking
from builtins import bool as _bool
from builtins import float as _float
from builtins import int as _int
from builtins import str as _str
from typing import (
    TYPE_CHECKING,
    Any,
    Callable,
    ClassVar,
    Dict,
    Generic,
    Iterable,
    Iterator,
    List,
    Mapping,
    NoReturn,
    Optional,
    Sequence,
    Set,
    Tuple,
    Type,
    TypeVar,
    Union,
    cast,
    overload,
)

from typing_extensions import Literal, TypedDict

LiteralString = str
# -- template engine/http.py.jinja --

import logging

from .._types import Method
from ..http import HTTP
from . import errors, utils
from .abstract import AbstractEngine

__all__ = (
    'HTTPEngine',
)

log: logging.Logger = logging.getLogger(__name__)


class HTTPEngine(AbstractEngine):
    """Engine wrapper that communicates to the underlying engine over HTTP"""
    url: Optional[str]
    session: HTTP
    headers: Dict[str, str]

    def __init__(
        self,
        url: Optional[str],
        headers: Optional[Dict[str, str]] = None,
        **kwargs: Any,
    ) -> None:
        self.url = url
        self.session = HTTP(**kwargs)
        self.headers = headers if headers is not None else {}

    def __del__(self) -> None:
        self.stop()

    def close(self) -> None:
        self._close_session()

    async def aclose(self) -> None:
        pass

    def _close_session(self) -> None:
        if self.session and not self.session.closed:
            self.session.close()

    def request(self, method: Method, path: str, *, content: Any = None) -> Any:
        if self.url is None:
            raise errors.NotConnectedError('Not connected to the query engine')

        kwargs = {
            'headers': {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
                **self.headers,
            }
        }

        if content is not None:
            kwargs['content'] = content

        url = self.url + path
        log.debug('Sending %s request to %s with content: %s', method, url, content)

        resp = self.session.request(method, url, **kwargs)

        if 300 > resp.status >= 200:
            response = resp.json()
            log.debug('%s %s returned %s', method, url, response)

            errors_data = response.get('errors')
            if errors_data:
                return utils.handle_response_errors(resp, errors_data)

            return response

        if resp.status == 422:
            raise errors.UnprocessableEntityError(resp)

        # TODO: handle errors better
        raise errors.EngineRequestError(resp, resp.text())


# black does not respect the fmt: off comment without this
# fmt: on
