/* tslint:disable */
/* eslint-disable */
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from "./base";

/**
 *
 * @export
 * @interface AllTagsResult
 */
export interface AllTagsResult {
  /**
   *
   * @type {Array<ProjectTagEntry>}
   * @memberof AllTagsResult
   */
  data: Array<ProjectTagEntry>;
  /**
   *
   * @type {Array<ProjectTagEntry>}
   * @memberof AllTagsResult
   */
  annotation: Array<ProjectTagEntry>;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const AnalysisBuckets = {
  NUMBER_10: 10,
  NUMBER_100: 100,
  NUMBER_1000: 1000,
} as const;

export type AnalysisBuckets =
  (typeof AnalysisBuckets)[keyof typeof AnalysisBuckets];

/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const AnalysisDomain = {
  Data: "data",
  Annotation: "annotation",
} as const;

export type AnalysisDomain =
  (typeof AnalysisDomain)[keyof typeof AnalysisDomain];

/**
 *
 * @export
 * @interface AnalysisSearch
 */
export interface AnalysisSearch {
  /**
   *
   * @type {boolean}
   * @memberof AnalysisSearch
   */
  truncated: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof AnalysisSearch
   */
  results: Array<string>;
  /**
   *
   * @type {Array<number>}
   * @memberof AnalysisSearch
   */
  similarities?: Array<number>;
}
/**
 *
 * @export
 * @interface AnnotationEnumItem
 */
export interface AnnotationEnumItem {
  /**
   *
   * @type {string}
   * @memberof AnnotationEnumItem
   */
  feature_hash: string;
  /**
   *
   * @type {AnnotationType}
   * @memberof AnnotationEnumItem
   */
  annotation_type: AnnotationType;
  /**
   *
   * @type {boolean}
   * @memberof AnnotationEnumItem
   */
  annotation_manual: boolean;
  /**
   *
   * @type {boolean}
   * @memberof AnnotationEnumItem
   */
  annotation_invalid: boolean;
  /**
   *
   * @type {number}
   * @memberof AnnotationEnumItem
   */
  annotation_user_id: number;
}

/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const AnnotationType = {
  CLASSIFICATION: 0,
  BOUNDING_BOX: 1,
  ROTATABLE_BOUNDING_BOX: 2,
  POINT: 3,
  POLYLINE: 4,
  POLYGON: 5,
  SKELETON: 6,
  BITMASK: 7,
} as const;

export type AnnotationType =
  (typeof AnnotationType)[keyof typeof AnnotationType];

/**
 *
 * @export
 * @interface BodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost
 */
export interface BodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost {
  /**
   *
   * @type {Array<string>}
   * @memberof BodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost
   */
  tags: Array<string>;
  /**
   *
   * @type {SearchFilters}
   * @memberof BodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost
   */
  filters: SearchFilters;
}
/**
 *
 * @export
 * @interface BodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost
 */
export interface BodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost {
  /**
   *
   * @type {Array<string>}
   * @memberof BodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost
   */
  tags: Array<string>;
  /**
   *
   * @type {SearchFilters}
   * @memberof BodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost
   */
  filters: SearchFilters;
}
/**
 *
 * @export
 * @interface BodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost
 */
export interface BodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost {
  /**
   *
   * @type {Array<string>}
   * @memberof BodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost
   */
  items: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof BodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost
   */
  tags: Array<string>;
}
/**
 *
 * @export
 * @interface BodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost
 */
export interface BodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost {
  /**
   *
   * @type {Array<string>}
   * @memberof BodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost
   */
  items: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof BodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost
   */
  tags: Array<string>;
}
/**
 *
 * @export
 * @interface CreateProjectSubsetPostAction
 */
export interface CreateProjectSubsetPostAction {
  /**
   *
   * @type {string}
   * @memberof CreateProjectSubsetPostAction
   */
  project_title: string;
  /**
   *
   * @type {string}
   * @memberof CreateProjectSubsetPostAction
   */
  project_description?: string;
  /**
   *
   * @type {string}
   * @memberof CreateProjectSubsetPostAction
   */
  dataset_title: string;
  /**
   *
   * @type {string}
   * @memberof CreateProjectSubsetPostAction
   */
  dataset_description?: string;
  /**
   *
   * @type {SearchFilters}
   * @memberof CreateProjectSubsetPostAction
   */
  filters: SearchFilters;
}
/**
 *
 * @export
 * @interface DataEnumItem
 */
export interface DataEnumItem {
  /**
   *
   * @type {DataType}
   * @memberof DataEnumItem
   */
  data_type: DataType;
}

/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const DataType = {
  IMAGE: 0,
  IMG_GROUP: 1,
  IMG_SEQUENCE: 2,
  VIDEO: 3,
} as const;

export type DataType = (typeof DataType)[keyof typeof DataType];

/**
 *
 * @export
 * @interface DomainSearchFilters
 */
export interface DomainSearchFilters {
  /**
   *
   * @type {{ [key: string]: Array<number> | undefined; }}
   * @memberof DomainSearchFilters
   */
  metrics: { [key: string]: Array<number> | undefined };
  /**
   *
   * @type {{ [key: string]: Array<string> | undefined; }}
   * @memberof DomainSearchFilters
   */
  enums: { [key: string]: Array<string> | undefined };
  /**
   *
   * @type {Embedding2DFilter}
   * @memberof DomainSearchFilters
   */
  reduction?: Embedding2DFilter;
  /**
   *
   * @type {Array<string>}
   * @memberof DomainSearchFilters
   */
  tags?: Array<string>;
}
/**
 *
 * @export
 * @interface Embedding2DFilter
 */
export interface Embedding2DFilter {
  /**
   *
   * @type {string}
   * @memberof Embedding2DFilter
   */
  reduction_hash: string;
  /**
   *
   * @type {number}
   * @memberof Embedding2DFilter
   */
  x1: number;
  /**
   *
   * @type {number}
   * @memberof Embedding2DFilter
   */
  x2: number;
  /**
   *
   * @type {number}
   * @memberof Embedding2DFilter
   */
  y1: number;
  /**
   *
   * @type {number}
   * @memberof Embedding2DFilter
   */
  y2: number;
}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const EmbeddingReductionType = {
  Umap: "umap",
  Pca: "pca",
} as const;

export type EmbeddingReductionType =
  (typeof EmbeddingReductionType)[keyof typeof EmbeddingReductionType];

/**
 *
 * @export
 * @interface EnumSummary
 */
export interface EnumSummary {
  /**
   *
   * @type {string}
   * @memberof EnumSummary
   */
  title: string;
  /**
   *
   * @type {{ [key: string]: string | undefined; }}
   * @memberof EnumSummary
   */
  values?: { [key: string]: string | undefined };
  /**
   *
   * @type {EnumType}
   * @memberof EnumSummary
   */
  type: EnumType;
}

/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const EnumType = {
  Ontology: "ontology",
  UserEmail: "user_email",
  Tags: "tags",
  Enum: "enum",
} as const;

export type EnumType = (typeof EnumType)[keyof typeof EnumType];

/**
 *
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
  /**
   *
   * @type {Array<ValidationError>}
   * @memberof HTTPValidationError
   */
  detail?: Array<ValidationError>;
}
/**
 *
 * @export
 * @interface ListProjectPredictionResult
 */
export interface ListProjectPredictionResult {
  /**
   *
   * @type {number}
   * @memberof ListProjectPredictionResult
   */
  total: number;
  /**
   *
   * @type {Array<ListProjectPredictionResultEntry>}
   * @memberof ListProjectPredictionResult
   */
  results: Array<ListProjectPredictionResultEntry>;
}
/**
 *
 * @export
 * @interface ListProjectPredictionResultEntry
 */
export interface ListProjectPredictionResultEntry {
  /**
   *
   * @type {string}
   * @memberof ListProjectPredictionResultEntry
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ListProjectPredictionResultEntry
   */
  prediction_hash: string;
}
/**
 *
 * @export
 * @interface LocationInner
 */
export interface LocationInner {}
/**
 *
 * @export
 * @interface MetricDissimilarityResult
 */
export interface MetricDissimilarityResult {
  /**
   *
   * @type {{ [key: string]: number | undefined; }}
   * @memberof MetricDissimilarityResult
   */
  results: { [key: string]: number | undefined };
}
/**
 *
 * @export
 * @interface MetricSummary
 */
export interface MetricSummary {
  /**
   *
   * @type {string}
   * @memberof MetricSummary
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof MetricSummary
   */
  short_desc: string;
  /**
   *
   * @type {string}
   * @memberof MetricSummary
   */
  long_desc: string;
  /**
   *
   * @type {MetricType}
   * @memberof MetricSummary
   */
  type: MetricType;
}

/**
 * Type of the metric
 * @export
 * @enum {string}
 */

export const MetricType = {
  Normal: "normal",
  Uint: "uint",
  Ufloat: "ufloat",
} as const;

export type MetricType = (typeof MetricType)[keyof typeof MetricType];

/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const PredictionDomain = {
  A: "a",
  P: "p",
  Tp: "tp",
  Fp: "fp",
  Fn: "fn",
} as const;

export type PredictionDomain =
  (typeof PredictionDomain)[keyof typeof PredictionDomain];

/**
 *
 * @export
 * @interface PredictionItem
 */
export interface PredictionItem {
  /**
   *
   * @type {{ [key: string]: { [key: string]: number | undefined; } | undefined; }}
   * @memberof PredictionItem
   */
  annotation_metrics: {
    [key: string]: { [key: string]: number | undefined } | undefined;
  };
  /**
   *
   * @type {{ [key: string]: AnnotationEnumItem | undefined; }}
   * @memberof PredictionItem
   */
  annotation_enums: { [key: string]: AnnotationEnumItem | undefined };
  /**
   *
   * @type {{ [key: string]: Array<number> | undefined; }}
   * @memberof PredictionItem
   */
  annotation_iou_bounds: { [key: string]: Array<number> | undefined };
  /**
   *
   * @type {Set<string>}
   * @memberof PredictionItem
   */
  annotation_feature_mismatch: Set<string>;
  /**
   *
   * @type {Array<object>}
   * @memberof PredictionItem
   */
  objects: Array<object>;
  /**
   *
   * @type {Array<object>}
   * @memberof PredictionItem
   */
  classifications: Array<object>;
  /**
   *
   * @type {{ [key: string]: object | undefined; }}
   * @memberof PredictionItem
   */
  object_answers: { [key: string]: object | undefined };
  /**
   *
   * @type {{ [key: string]: object | undefined; }}
   * @memberof PredictionItem
   */
  classification_answers: { [key: string]: object | undefined };
  /**
   *
   * @type {string}
   * @memberof PredictionItem
   */
  label_hash: string;
}
/**
 *
 * @export
 * @interface PredictionPRPoint
 */
export interface PredictionPRPoint {
  /**
   *
   * @type {number}
   * @memberof PredictionPRPoint
   */
  p: number;
  /**
   *
   * @type {number}
   * @memberof PredictionPRPoint
   */
  r: number;
}
/**
 *
 * @export
 * @interface PredictionQuery2DEmbedding
 */
export interface PredictionQuery2DEmbedding {
  /**
   *
   * @type {number}
   * @memberof PredictionQuery2DEmbedding
   */
  count: number;
  /**
   *
   * @type {Array<PredictionQueryScatterPoint>}
   * @memberof PredictionQuery2DEmbedding
   */
  reductions: Array<PredictionQueryScatterPoint>;
}
/**
 *
 * @export
 * @interface PredictionQueryScatterPoint
 */
export interface PredictionQueryScatterPoint {
  /**
   *
   * @type {number}
   * @memberof PredictionQueryScatterPoint
   */
  x: number;
  /**
   *
   * @type {number}
   * @memberof PredictionQueryScatterPoint
   */
  y: number;
  /**
   *
   * @type {number}
   * @memberof PredictionQueryScatterPoint
   */
  n: number;
  /**
   *
   * @type {number}
   * @memberof PredictionQueryScatterPoint
   */
  tp: number;
  /**
   *
   * @type {number}
   * @memberof PredictionQueryScatterPoint
   */
  fp: number;
  /**
   *
   * @type {number}
   * @memberof PredictionQueryScatterPoint
   */
  fn: number;
}
/**
 *
 * @export
 * @interface PredictionSummaryFeatureResult
 */
export interface PredictionSummaryFeatureResult {
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryFeatureResult
   */
  ap: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryFeatureResult
   */
  ar: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryFeatureResult
   */
  p: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryFeatureResult
   */
  r: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryFeatureResult
   */
  f1: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryFeatureResult
   */
  tp: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryFeatureResult
   */
  fp: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryFeatureResult
   */
  fn: number;
}
/**
 *
 * @export
 * @interface PredictionSummaryResult
 */
export interface PredictionSummaryResult {
  /**
   *
   * @type {boolean}
   * @memberof PredictionSummaryResult
   */
  classification_only: boolean;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryResult
   */
  classification_tTN?: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryResult
   */
  classification_accuracy?: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryResult
   */
  num_frames: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryResult
   */
  mAP: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryResult
   */
  mAR: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryResult
   */
  mP: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryResult
   */
  mR: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryResult
   */
  mF1: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryResult
   */
  tTP: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryResult
   */
  tFP: number;
  /**
   *
   * @type {number}
   * @memberof PredictionSummaryResult
   */
  tFN: number;
  /**
   *
   * @type {{ [key: string]: PredictionSummaryFeatureResult | undefined; }}
   * @memberof PredictionSummaryResult
   */
  feature_properties: {
    [key: string]: PredictionSummaryFeatureResult | undefined;
  };
  /**
   *
   * @type {{ [key: string]: Array<PredictionPRPoint> | undefined; }}
   * @memberof PredictionSummaryResult
   */
  prs: { [key: string]: Array<PredictionPRPoint> | undefined };
  /**
   *
   * @type {{ [key: string]: number | undefined; }}
   * @memberof PredictionSummaryResult
   */
  correlation: { [key: string]: number | undefined };
  /**
   *
   * @type {{ [key: string]: number | undefined; }}
   * @memberof PredictionSummaryResult
   */
  importance: { [key: string]: number | undefined };
}
/**
 *
 * @export
 * @interface ProjectCollaboratorEntry
 */
export interface ProjectCollaboratorEntry {
  /**
   *
   * @type {string}
   * @memberof ProjectCollaboratorEntry
   */
  email: string;
  /**
   *
   * @type {number}
   * @memberof ProjectCollaboratorEntry
   */
  id: number;
}
/**
 *
 * @export
 * @interface ProjectDomainSummary
 */
export interface ProjectDomainSummary {
  /**
   *
   * @type {{ [key: string]: MetricSummary | undefined; }}
   * @memberof ProjectDomainSummary
   */
  metrics: { [key: string]: MetricSummary | undefined };
  /**
   *
   * @type {{ [key: string]: EnumSummary | undefined; }}
   * @memberof ProjectDomainSummary
   */
  enums: { [key: string]: EnumSummary | undefined };
}
/**
 *
 * @export
 * @interface ProjectItem
 */
export interface ProjectItem {
  /**
   *
   * @type {{ [key: string]: number | undefined; }}
   * @memberof ProjectItem
   */
  data_metrics: { [key: string]: number | undefined };
  /**
   *
   * @type {{ [key: string]: { [key: string]: number | undefined; } | undefined; }}
   * @memberof ProjectItem
   */
  annotation_metrics: {
    [key: string]: { [key: string]: number | undefined } | undefined;
  };
  /**
   *
   * @type {DataEnumItem}
   * @memberof ProjectItem
   */
  data_enums: DataEnumItem;
  /**
   *
   * @type {{ [key: string]: AnnotationEnumItem | undefined; }}
   * @memberof ProjectItem
   */
  annotation_enums: { [key: string]: AnnotationEnumItem | undefined };
  /**
   *
   * @type {Array<object>}
   * @memberof ProjectItem
   */
  objects: Array<object>;
  /**
   *
   * @type {Array<object>}
   * @memberof ProjectItem
   */
  classifications: Array<object>;
  /**
   *
   * @type {{ [key: string]: object | undefined; }}
   * @memberof ProjectItem
   */
  object_answers: { [key: string]: object | undefined };
  /**
   *
   * @type {{ [key: string]: object | undefined; }}
   * @memberof ProjectItem
   */
  classification_answers: { [key: string]: object | undefined };
  /**
   *
   * @type {string}
   * @memberof ProjectItem
   */
  dataset_title: string;
  /**
   *
   * @type {string}
   * @memberof ProjectItem
   */
  dataset_hash: string;
  /**
   *
   * @type {string}
   * @memberof ProjectItem
   */
  data_title: string;
  /**
   *
   * @type {string}
   * @memberof ProjectItem
   */
  data_hash: string;
  /**
   *
   * @type {string}
   * @memberof ProjectItem
   */
  label_hash: string;
  /**
   *
   * @type {number}
   * @memberof ProjectItem
   */
  num_frames: number;
  /**
   *
   * @type {number}
   * @memberof ProjectItem
   */
  frames_per_second?: number;
  /**
   *
   * @type {string}
   * @memberof ProjectItem
   */
  data_type: string;
  /**
   *
   * @type {string}
   * @memberof ProjectItem
   */
  url: string;
  /**
   *
   * @type {number}
   * @memberof ProjectItem
   */
  timestamp?: number;
  /**
   *
   * @type {ProjectItemTags}
   * @memberof ProjectItem
   */
  tags: ProjectItemTags;
}
/**
 *
 * @export
 * @interface ProjectItemTags
 */
export interface ProjectItemTags {
  /**
   *
   * @type {Array<ProjectTag>}
   * @memberof ProjectItemTags
   */
  data: Array<ProjectTag>;
  /**
   *
   * @type {{ [key: string]: Array<ProjectTag> | undefined; }}
   * @memberof ProjectItemTags
   */
  label: { [key: string]: Array<ProjectTag> | undefined };
}
/**
 *
 * @export
 * @interface ProjectList2DEmbeddingReductionResult
 */
export interface ProjectList2DEmbeddingReductionResult {
  /**
   *
   * @type {number}
   * @memberof ProjectList2DEmbeddingReductionResult
   */
  total: number;
  /**
   *
   * @type {Array<ProjectList2DEmbeddingReductionResultEntry>}
   * @memberof ProjectList2DEmbeddingReductionResult
   */
  results: Array<ProjectList2DEmbeddingReductionResultEntry>;
}
/**
 *
 * @export
 * @interface ProjectList2DEmbeddingReductionResultEntry
 */
export interface ProjectList2DEmbeddingReductionResultEntry {
  /**
   *
   * @type {string}
   * @memberof ProjectList2DEmbeddingReductionResultEntry
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ProjectList2DEmbeddingReductionResultEntry
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof ProjectList2DEmbeddingReductionResultEntry
   */
  hash: string;
  /**
   *
   * @type {EmbeddingReductionType}
   * @memberof ProjectList2DEmbeddingReductionResultEntry
   */
  type: EmbeddingReductionType;
}

/**
 *
 * @export
 * @interface ProjectMetadata
 */
export interface ProjectMetadata {
  /**
   *
   * @type {number}
   * @memberof ProjectMetadata
   */
  data_count: number;
  /**
   *
   * @type {number}
   * @memberof ProjectMetadata
   */
  annotation_count: number;
  /**
   *
   * @type {number}
   * @memberof ProjectMetadata
   */
  class_count: number;
}
/**
 *
 * @export
 * @interface ProjectSandboxEntry
 */
export interface ProjectSandboxEntry {
  /**
   *
   * @type {string}
   * @memberof ProjectSandboxEntry
   */
  project_hash: string;
  /**
   *
   * @type {string}
   * @memberof ProjectSandboxEntry
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof ProjectSandboxEntry
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof ProjectSandboxEntry
   */
  sandbox_url: string;
  /**
   *
   * @type {number}
   * @memberof ProjectSandboxEntry
   */
  data_count: number;
  /**
   *
   * @type {number}
   * @memberof ProjectSandboxEntry
   */
  annotation_count: number;
  /**
   *
   * @type {number}
   * @memberof ProjectSandboxEntry
   */
  class_count: number;
}
/**
 *
 * @export
 * @interface ProjectSearchEntry
 */
export interface ProjectSearchEntry {
  /**
   *
   * @type {string}
   * @memberof ProjectSearchEntry
   */
  project_hash: string;
  /**
   *
   * @type {string}
   * @memberof ProjectSearchEntry
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof ProjectSearchEntry
   */
  description: string;
  /**
   *
   * @type {boolean}
   * @memberof ProjectSearchEntry
   */
  sandbox: boolean;
}
/**
 *
 * @export
 * @interface ProjectSearchResult
 */
export interface ProjectSearchResult {
  /**
   *
   * @type {Array<ProjectSearchEntry>}
   * @memberof ProjectSearchResult
   */
  projects: Array<ProjectSearchEntry>;
  /**
   *
   * @type {Array<ProjectSandboxEntry>}
   * @memberof ProjectSearchResult
   */
  sandbox_projects: Array<ProjectSandboxEntry>;
}
/**
 *
 * @export
 * @interface ProjectSummary
 */
export interface ProjectSummary {
  /**
   *
   * @type {string}
   * @memberof ProjectSummary
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ProjectSummary
   */
  description: string;
  /**
   *
   * @type {object}
   * @memberof ProjectSummary
   */
  ontology: object;
  /**
   *
   * @type {boolean}
   * @memberof ProjectSummary
   */
  local_project: boolean;
  /**
   *
   * @type {ProjectDomainSummary}
   * @memberof ProjectSummary
   */
  data: ProjectDomainSummary;
  /**
   *
   * @type {ProjectDomainSummary}
   * @memberof ProjectSummary
   */
  annotation: ProjectDomainSummary;
  /**
   *
   * @type {number}
   * @memberof ProjectSummary
   */
  du_count: number;
  /**
   *
   * @type {number}
   * @memberof ProjectSummary
   */
  frame_count: number;
  /**
   *
   * @type {number}
   * @memberof ProjectSummary
   */
  annotation_count: number;
  /**
   *
   * @type {number}
   * @memberof ProjectSummary
   */
  classification_count: number;
  /**
   *
   * @type {ProjectDomainSummary}
   * @memberof ProjectSummary
   */
  data_annotation: ProjectDomainSummary;
  /**
   *
   * @type {{ [key: string]: string | undefined; }}
   * @memberof ProjectSummary
   */
  tags: { [key: string]: string | undefined };
  /**
   *
   * @type {string}
   * @memberof ProjectSummary
   */
  preview?: string;
}
/**
 *
 * @export
 * @interface ProjectTag
 */
export interface ProjectTag {
  /**
   *
   * @type {string}
   * @memberof ProjectTag
   */
  tag_hash: string;
  /**
   *
   * @type {string}
   * @memberof ProjectTag
   */
  project_hash: string;
  /**
   *
   * @type {string}
   * @memberof ProjectTag
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ProjectTag
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof ProjectTag
   */
  created_at?: string;
  /**
   *
   * @type {string}
   * @memberof ProjectTag
   */
  updated_at?: string;
}
/**
 *
 * @export
 * @interface ProjectTagEntry
 */
export interface ProjectTagEntry {
  /**
   *
   * @type {string}
   * @memberof ProjectTagEntry
   */
  hash: string;
  /**
   *
   * @type {string}
   * @memberof ProjectTagEntry
   */
  name: string;
}
/**
 *
 * @export
 * @interface ProjectTagEntryMeta
 */
export interface ProjectTagEntryMeta {
  /**
   *
   * @type {string}
   * @memberof ProjectTagEntryMeta
   */
  hash: string;
  /**
   *
   * @type {string}
   * @memberof ProjectTagEntryMeta
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ProjectTagEntryMeta
   */
  description: string;
  /**
   *
   * @type {number}
   * @memberof ProjectTagEntryMeta
   */
  dataCount: number;
  /**
   *
   * @type {number}
   * @memberof ProjectTagEntryMeta
   */
  labelCount: number;
  /**
   *
   * @type {string}
   * @memberof ProjectTagEntryMeta
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof ProjectTagEntryMeta
   */
  updatedAt?: string;
}
/**
 *
 * @export
 * @interface ProjectTagRequest
 */
export interface ProjectTagRequest {
  /**
   *
   * @type {string}
   * @memberof ProjectTagRequest
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ProjectTagRequest
   */
  description: string;
}
/**
 *
 * @export
 * @interface Query2DEmbedding
 */
export interface Query2DEmbedding {
  /**
   *
   * @type {number}
   * @memberof Query2DEmbedding
   */
  count: number;
  /**
   *
   * @type {Array<Query2DEmbeddingScatterPoint>}
   * @memberof Query2DEmbedding
   */
  reductions: Array<Query2DEmbeddingScatterPoint>;
}
/**
 *
 * @export
 * @interface Query2DEmbeddingScatterPoint
 */
export interface Query2DEmbeddingScatterPoint {
  /**
   *
   * @type {number}
   * @memberof Query2DEmbeddingScatterPoint
   */
  x: number;
  /**
   *
   * @type {number}
   * @memberof Query2DEmbeddingScatterPoint
   */
  y: number;
  /**
   *
   * @type {string}
   * @memberof Query2DEmbeddingScatterPoint
   */
  fh: string;
  /**
   *
   * @type {number}
   * @memberof Query2DEmbeddingScatterPoint
   */
  fhn: number;
  /**
   *
   * @type {number}
   * @memberof Query2DEmbeddingScatterPoint
   */
  n: number;
}
/**
 *
 * @export
 * @interface QueryDistribution
 */
export interface QueryDistribution {
  /**
   *
   * @type {Array<QueryDistributionGroup>}
   * @memberof QueryDistribution
   */
  results: Array<QueryDistributionGroup>;
}
/**
 *
 * @export
 * @interface QueryDistributionGroup
 */
export interface QueryDistributionGroup {
  /**
   *
   * @type {string}
   * @memberof QueryDistributionGroup
   */
  group: string;
  /**
   *
   * @type {number}
   * @memberof QueryDistributionGroup
   */
  count: number;
}
/**
 *
 * @export
 * @interface QueryEnumSummary
 */
export interface QueryEnumSummary {
  /**
   *
   * @type {number}
   * @memberof QueryEnumSummary
   */
  count: number;
}
/**
 *
 * @export
 * @interface QueryMetricPerformance
 */
export interface QueryMetricPerformance {
  /**
   *
   * @type {{ [key: string]: Array<QueryMetricPerformanceEntry> | undefined; }}
   * @memberof QueryMetricPerformance
   */
  precision: { [key: string]: Array<QueryMetricPerformanceEntry> | undefined };
  /**
   *
   * @type {{ [key: string]: Array<QueryMetricPerformanceEntry> | undefined; }}
   * @memberof QueryMetricPerformance
   */
  fns: { [key: string]: Array<QueryMetricPerformanceEntry> | undefined };
}
/**
 *
 * @export
 * @interface QueryMetricPerformanceEntry
 */
export interface QueryMetricPerformanceEntry {
  /**
   *
   * @type {number}
   * @memberof QueryMetricPerformanceEntry
   */
  m: number;
  /**
   *
   * @type {number}
   * @memberof QueryMetricPerformanceEntry
   */
  a: number;
  /**
   *
   * @type {number}
   * @memberof QueryMetricPerformanceEntry
   */
  n: number;
}
/**
 *
 * @export
 * @interface QueryMetricSummary
 */
export interface QueryMetricSummary {
  /**
   *
   * @type {number}
   * @memberof QueryMetricSummary
   */
  min: number;
  /**
   *
   * @type {number}
   * @memberof QueryMetricSummary
   */
  q1: number;
  /**
   *
   * @type {number}
   * @memberof QueryMetricSummary
   */
  median: number;
  /**
   *
   * @type {number}
   * @memberof QueryMetricSummary
   */
  q3: number;
  /**
   *
   * @type {number}
   * @memberof QueryMetricSummary
   */
  max: number;
  /**
   *
   * @type {number}
   * @memberof QueryMetricSummary
   */
  count: number;
  /**
   *
   * @type {number}
   * @memberof QueryMetricSummary
   */
  moderate: number;
  /**
   *
   * @type {number}
   * @memberof QueryMetricSummary
   */
  severe: number;
}
/**
 *
 * @export
 * @interface QueryScatter
 */
export interface QueryScatter {
  /**
   *
   * @type {Array<QueryScatterPoint>}
   * @memberof QueryScatter
   */
  samples: Array<QueryScatterPoint>;
}
/**
 *
 * @export
 * @interface QueryScatterPoint
 */
export interface QueryScatterPoint {
  /**
   *
   * @type {number}
   * @memberof QueryScatterPoint
   */
  x: number;
  /**
   *
   * @type {number}
   * @memberof QueryScatterPoint
   */
  y: number;
  /**
   *
   * @type {number}
   * @memberof QueryScatterPoint
   */
  n: number;
}
/**
 *
 * @export
 * @interface QuerySummary
 */
export interface QuerySummary {
  /**
   *
   * @type {number}
   * @memberof QuerySummary
   */
  count: number;
  /**
   *
   * @type {{ [key: string]: QueryMetricSummary | undefined; }}
   * @memberof QuerySummary
   */
  metrics: { [key: string]: QueryMetricSummary | undefined };
  /**
   *
   * @type {{ [key: string]: QueryEnumSummary | undefined; }}
   * @memberof QuerySummary
   */
  enums: { [key: string]: QueryEnumSummary | undefined };
}
/**
 *
 * @export
 * @interface SearchFilters
 */
export interface SearchFilters {
  /**
   *
   * @type {DomainSearchFilters}
   * @memberof SearchFilters
   */
  data?: DomainSearchFilters;
  /**
   *
   * @type {DomainSearchFilters}
   * @memberof SearchFilters
   */
  annotation?: DomainSearchFilters;
}
/**
 *
 * @export
 * @interface UploadProjectToEncordPostAction
 */
export interface UploadProjectToEncordPostAction {
  /**
   *
   * @type {string}
   * @memberof UploadProjectToEncordPostAction
   */
  project_title: string;
  /**
   *
   * @type {string}
   * @memberof UploadProjectToEncordPostAction
   */
  project_description?: string;
  /**
   *
   * @type {string}
   * @memberof UploadProjectToEncordPostAction
   */
  dataset_title: string;
  /**
   *
   * @type {string}
   * @memberof UploadProjectToEncordPostAction
   */
  dataset_description?: string;
  /**
   *
   * @type {string}
   * @memberof UploadProjectToEncordPostAction
   */
  ontology_title: string;
  /**
   *
   * @type {string}
   * @memberof UploadProjectToEncordPostAction
   */
  ontology_description?: string;
}
/**
 *
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
  /**
   *
   * @type {Array<LocationInner>}
   * @memberof ValidationError
   */
  loc: Array<LocationInner>;
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  msg: string;
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  type: string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    healthCheck: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async healthCheck(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.healthCheck(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = DefaultApiFp(configuration);
  return {
    /**
     *
     * @summary Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    healthCheck(options?: any): AxiosPromise<boolean> {
      return localVarFp
        .healthCheck(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   *
   * @summary Health Check
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public healthCheck(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .healthCheck(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PredictionApi - axios parameter creator
 * @export
 */
export const PredictionApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Route Create Tags
     * @param {string} projectHash
     * @param {Array<ProjectTagRequest>} projectTagRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeCreateTags: async (
      projectHash: string,
      projectTagRequest: Array<ProjectTagRequest>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeCreateTags", "projectHash", projectHash);
      // verify required parameter 'projectTagRequest' is not null or undefined
      assertParamExists(
        "routeCreateTags",
        "projectTagRequest",
        projectTagRequest
      );
      const localVarPath = `/api/projects_v2/{project_hash}/tags/`.replace(
        `{${"project_hash"}}`,
        encodeURIComponent(String(projectHash))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        projectTagRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Delete Tag
     * @param {string} projectHash
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeDeleteTag: async (
      projectHash: string,
      requestBody: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeDeleteTag", "projectHash", projectHash);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("routeDeleteTag", "requestBody", requestBody);
      const localVarPath = `/api/projects_v2/{project_hash}/tags/`.replace(
        `{${"project_hash"}}`,
        encodeURIComponent(String(projectHash))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Filter All Tags
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {SearchFilters} searchFilters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeFilterAllTags: async (
      projectHash: string,
      domain: AnalysisDomain,
      searchFilters: SearchFilters,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeFilterAllTags", "projectHash", projectHash);
      // verify required parameter 'domain' is not null or undefined
      assertParamExists("routeFilterAllTags", "domain", domain);
      // verify required parameter 'searchFilters' is not null or undefined
      assertParamExists("routeFilterAllTags", "searchFilters", searchFilters);
      const localVarPath =
        `/api/projects_v2/{project_hash}/tags/{domain}/filter/all_tags`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        searchFilters,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Filter Tag All
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {BodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost} bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeFilterTagAll: async (
      projectHash: string,
      domain: AnalysisDomain,
      bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost: BodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeFilterTagAll", "projectHash", projectHash);
      // verify required parameter 'domain' is not null or undefined
      assertParamExists("routeFilterTagAll", "domain", domain);
      // verify required parameter 'bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost' is not null or undefined
      assertParamExists(
        "routeFilterTagAll",
        "bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost",
        bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost
      );
      const localVarPath =
        `/api/projects_v2/{project_hash}/tags/{domain}/filter/tag_all`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Filter Untag All
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {BodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost} bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeFilterUntagAll: async (
      projectHash: string,
      domain: AnalysisDomain,
      bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost: BodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeFilterUntagAll", "projectHash", projectHash);
      // verify required parameter 'domain' is not null or undefined
      assertParamExists("routeFilterUntagAll", "domain", domain);
      // verify required parameter 'bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost' is not null or undefined
      assertParamExists(
        "routeFilterUntagAll",
        "bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost",
        bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost
      );
      const localVarPath =
        `/api/projects_v2/{project_hash}/tags/{domain}/filter/untag_all`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Items All Tags
     * @param {string} projectHash
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeItemsAllTags: async (
      projectHash: string,
      requestBody: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeItemsAllTags", "projectHash", projectHash);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("routeItemsAllTags", "requestBody", requestBody);
      const localVarPath =
        `/api/projects_v2/{project_hash}/tags/items/all_tags`.replace(
          `{${"project_hash"}}`,
          encodeURIComponent(String(projectHash))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Items Tag All
     * @param {string} projectHash
     * @param {BodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost} bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeItemsTagAll: async (
      projectHash: string,
      bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost: BodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeItemsTagAll", "projectHash", projectHash);
      // verify required parameter 'bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost' is not null or undefined
      assertParamExists(
        "routeItemsTagAll",
        "bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost",
        bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost
      );
      const localVarPath =
        `/api/projects_v2/{project_hash}/tags/items/tag_all`.replace(
          `{${"project_hash"}}`,
          encodeURIComponent(String(projectHash))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Items Untag All
     * @param {string} projectHash
     * @param {BodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost} bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeItemsUntagAll: async (
      projectHash: string,
      bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost: BodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeItemsUntagAll", "projectHash", projectHash);
      // verify required parameter 'bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost' is not null or undefined
      assertParamExists(
        "routeItemsUntagAll",
        "bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost",
        bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost
      );
      const localVarPath =
        `/api/projects_v2/{project_hash}/tags/items/untag_all`.replace(
          `{${"project_hash"}}`,
          encodeURIComponent(String(projectHash))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route List Tags
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeListTags: async (
      projectHash: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeListTags", "projectHash", projectHash);
      const localVarPath = `/api/projects_v2/{project_hash}/tags/`.replace(
        `{${"project_hash"}}`,
        encodeURIComponent(String(projectHash))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route List Tags Meta
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeListTagsMeta: async (
      projectHash: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeListTagsMeta", "projectHash", projectHash);
      const localVarPath = `/api/projects_v2/{project_hash}/tags/meta`.replace(
        `{${"project_hash"}}`,
        encodeURIComponent(String(projectHash))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Prediction Data Item
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {string} dataItem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionDataItem: async (
      projectHash: string,
      predictionHash: string,
      dataItem: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routePredictionDataItem", "projectHash", projectHash);
      // verify required parameter 'predictionHash' is not null or undefined
      assertParamExists(
        "routePredictionDataItem",
        "predictionHash",
        predictionHash
      );
      // verify required parameter 'dataItem' is not null or undefined
      assertParamExists("routePredictionDataItem", "dataItem", dataItem);
      const localVarPath =
        `/api/projects_v2/{project_hash}/predictions/{prediction_hash}/preview/{data_item}`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(
            `{${"prediction_hash"}}`,
            encodeURIComponent(String(predictionHash))
          )
          .replace(`{${"data_item"}}`, encodeURIComponent(String(dataItem)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Prediction Distribution
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {string} group
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionDistribution: async (
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      group: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routePredictionDistribution",
        "projectHash",
        projectHash
      );
      // verify required parameter 'predictionHash' is not null or undefined
      assertParamExists(
        "routePredictionDistribution",
        "predictionHash",
        predictionHash
      );
      // verify required parameter 'domain' is not null or undefined
      assertParamExists("routePredictionDistribution", "domain", domain);
      // verify required parameter 'iou' is not null or undefined
      assertParamExists("routePredictionDistribution", "iou", iou);
      // verify required parameter 'group' is not null or undefined
      assertParamExists("routePredictionDistribution", "group", group);
      const localVarPath =
        `/api/projects_v2/{project_hash}/predictions/{prediction_hash}/analytics/{domain}/distribution`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(
            `{${"prediction_hash"}}`,
            encodeURIComponent(String(predictionHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (iou !== undefined) {
        localVarQueryParameter["iou"] = iou;
      }

      if (group !== undefined) {
        localVarQueryParameter["group"] = group;
      }

      if (buckets !== undefined) {
        localVarQueryParameter["buckets"] = buckets;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Prediction Distribution
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {string} group
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionDistribution_1: async (
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      group: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routePredictionDistribution_1",
        "projectHash",
        projectHash
      );
      // verify required parameter 'predictionHash' is not null or undefined
      assertParamExists(
        "routePredictionDistribution_1",
        "predictionHash",
        predictionHash
      );
      // verify required parameter 'domain' is not null or undefined
      assertParamExists("routePredictionDistribution_1", "domain", domain);
      // verify required parameter 'iou' is not null or undefined
      assertParamExists("routePredictionDistribution_1", "iou", iou);
      // verify required parameter 'group' is not null or undefined
      assertParamExists("routePredictionDistribution_1", "group", group);
      const localVarPath =
        `/api/projects_v2/{project_hash}/predictions/{prediction_hash}/analytics/{domain}/distribution`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(
            `{${"prediction_hash"}}`,
            encodeURIComponent(String(predictionHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (iou !== undefined) {
        localVarQueryParameter["iou"] = iou;
      }

      if (group !== undefined) {
        localVarQueryParameter["group"] = group;
      }

      if (buckets !== undefined) {
        localVarQueryParameter["buckets"] = buckets;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Prediction Metric Performance
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {number} iou
     * @param {string} metricName
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionMetricPerformance: async (
      projectHash: string,
      predictionHash: string,
      iou: number,
      metricName: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routePredictionMetricPerformance",
        "projectHash",
        projectHash
      );
      // verify required parameter 'predictionHash' is not null or undefined
      assertParamExists(
        "routePredictionMetricPerformance",
        "predictionHash",
        predictionHash
      );
      // verify required parameter 'iou' is not null or undefined
      assertParamExists("routePredictionMetricPerformance", "iou", iou);
      // verify required parameter 'metricName' is not null or undefined
      assertParamExists(
        "routePredictionMetricPerformance",
        "metricName",
        metricName
      );
      const localVarPath =
        `/api/projects_v2/{project_hash}/predictions/{prediction_hash}/metric_performance`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(
            `{${"prediction_hash"}}`,
            encodeURIComponent(String(predictionHash))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (iou !== undefined) {
        localVarQueryParameter["iou"] = iou;
      }

      if (metricName !== undefined) {
        localVarQueryParameter["metric_name"] = metricName;
      }

      if (buckets !== undefined) {
        localVarQueryParameter["buckets"] = buckets;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Prediction Reduction Scatter
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {string} reductionHash
     * @param {number} iou
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionReductionScatter: async (
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      reductionHash: string,
      iou: number,
      buckets?: AnalysisBuckets,
      filters?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routePredictionReductionScatter",
        "projectHash",
        projectHash
      );
      // verify required parameter 'predictionHash' is not null or undefined
      assertParamExists(
        "routePredictionReductionScatter",
        "predictionHash",
        predictionHash
      );
      // verify required parameter 'domain' is not null or undefined
      assertParamExists("routePredictionReductionScatter", "domain", domain);
      // verify required parameter 'reductionHash' is not null or undefined
      assertParamExists(
        "routePredictionReductionScatter",
        "reductionHash",
        reductionHash
      );
      // verify required parameter 'iou' is not null or undefined
      assertParamExists("routePredictionReductionScatter", "iou", iou);
      const localVarPath =
        `/api/projects_v2/{project_hash}/predictions/{prediction_hash}/analytics/{domain}/reductions/{reduction_hash}/summary`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(
            `{${"prediction_hash"}}`,
            encodeURIComponent(String(predictionHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)))
          .replace(
            `{${"reduction_hash"}}`,
            encodeURIComponent(String(reductionHash))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (iou !== undefined) {
        localVarQueryParameter["iou"] = iou;
      }

      if (buckets !== undefined) {
        localVarQueryParameter["buckets"] = buckets;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Prediction Reduction Scatter
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {string} reductionHash
     * @param {number} iou
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionReductionScatter_2: async (
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      reductionHash: string,
      iou: number,
      buckets?: AnalysisBuckets,
      filters?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routePredictionReductionScatter_2",
        "projectHash",
        projectHash
      );
      // verify required parameter 'predictionHash' is not null or undefined
      assertParamExists(
        "routePredictionReductionScatter_2",
        "predictionHash",
        predictionHash
      );
      // verify required parameter 'domain' is not null or undefined
      assertParamExists("routePredictionReductionScatter_2", "domain", domain);
      // verify required parameter 'reductionHash' is not null or undefined
      assertParamExists(
        "routePredictionReductionScatter_2",
        "reductionHash",
        reductionHash
      );
      // verify required parameter 'iou' is not null or undefined
      assertParamExists("routePredictionReductionScatter_2", "iou", iou);
      const localVarPath =
        `/api/projects_v2/{project_hash}/predictions/{prediction_hash}/analytics/{domain}/reductions/{reduction_hash}/summary`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(
            `{${"prediction_hash"}}`,
            encodeURIComponent(String(predictionHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)))
          .replace(
            `{${"reduction_hash"}}`,
            encodeURIComponent(String(reductionHash))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (iou !== undefined) {
        localVarQueryParameter["iou"] = iou;
      }

      if (buckets !== undefined) {
        localVarQueryParameter["buckets"] = buckets;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Prediction Scatter
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {string} xMetric
     * @param {string} yMetric
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionScatter: async (
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      xMetric: string,
      yMetric: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routePredictionScatter", "projectHash", projectHash);
      // verify required parameter 'predictionHash' is not null or undefined
      assertParamExists(
        "routePredictionScatter",
        "predictionHash",
        predictionHash
      );
      // verify required parameter 'domain' is not null or undefined
      assertParamExists("routePredictionScatter", "domain", domain);
      // verify required parameter 'iou' is not null or undefined
      assertParamExists("routePredictionScatter", "iou", iou);
      // verify required parameter 'xMetric' is not null or undefined
      assertParamExists("routePredictionScatter", "xMetric", xMetric);
      // verify required parameter 'yMetric' is not null or undefined
      assertParamExists("routePredictionScatter", "yMetric", yMetric);
      const localVarPath =
        `/api/projects_v2/{project_hash}/predictions/{prediction_hash}/analytics/{domain}/scatter`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(
            `{${"prediction_hash"}}`,
            encodeURIComponent(String(predictionHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (iou !== undefined) {
        localVarQueryParameter["iou"] = iou;
      }

      if (xMetric !== undefined) {
        localVarQueryParameter["x_metric"] = xMetric;
      }

      if (yMetric !== undefined) {
        localVarQueryParameter["y_metric"] = yMetric;
      }

      if (buckets !== undefined) {
        localVarQueryParameter["buckets"] = buckets;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Prediction Scatter
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {string} xMetric
     * @param {string} yMetric
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionScatter_3: async (
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      xMetric: string,
      yMetric: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routePredictionScatter_3", "projectHash", projectHash);
      // verify required parameter 'predictionHash' is not null or undefined
      assertParamExists(
        "routePredictionScatter_3",
        "predictionHash",
        predictionHash
      );
      // verify required parameter 'domain' is not null or undefined
      assertParamExists("routePredictionScatter_3", "domain", domain);
      // verify required parameter 'iou' is not null or undefined
      assertParamExists("routePredictionScatter_3", "iou", iou);
      // verify required parameter 'xMetric' is not null or undefined
      assertParamExists("routePredictionScatter_3", "xMetric", xMetric);
      // verify required parameter 'yMetric' is not null or undefined
      assertParamExists("routePredictionScatter_3", "yMetric", yMetric);
      const localVarPath =
        `/api/projects_v2/{project_hash}/predictions/{prediction_hash}/analytics/{domain}/scatter`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(
            `{${"prediction_hash"}}`,
            encodeURIComponent(String(predictionHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (iou !== undefined) {
        localVarQueryParameter["iou"] = iou;
      }

      if (xMetric !== undefined) {
        localVarQueryParameter["x_metric"] = xMetric;
      }

      if (yMetric !== undefined) {
        localVarQueryParameter["y_metric"] = yMetric;
      }

      if (buckets !== undefined) {
        localVarQueryParameter["buckets"] = buckets;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Prediction Search
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {boolean} desc
     * @param {string} [filters] Search Filters
     * @param {string} [orderBy]
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [text]
     * @param {File} [image]
     * @param {string} [item]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionSearch: async (
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      desc: boolean,
      filters?: string,
      orderBy?: string,
      offset?: number,
      limit?: number,
      text?: string,
      image?: File,
      item?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routePredictionSearch", "projectHash", projectHash);
      // verify required parameter 'predictionHash' is not null or undefined
      assertParamExists(
        "routePredictionSearch",
        "predictionHash",
        predictionHash
      );
      // verify required parameter 'domain' is not null or undefined
      assertParamExists("routePredictionSearch", "domain", domain);
      // verify required parameter 'iou' is not null or undefined
      assertParamExists("routePredictionSearch", "iou", iou);
      // verify required parameter 'desc' is not null or undefined
      assertParamExists("routePredictionSearch", "desc", desc);
      const localVarPath =
        `/api/projects_v2/{project_hash}/predictions/{prediction_hash}/analytics/{domain}/search`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(
            `{${"prediction_hash"}}`,
            encodeURIComponent(String(predictionHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)();

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      if (iou !== undefined) {
        localVarFormParams.append("iou", iou as any);
      }

      if (orderBy !== undefined) {
        localVarFormParams.append("order_by", orderBy as any);
      }

      if (desc !== undefined) {
        localVarFormParams.append("desc", desc as any);
      }

      if (offset !== undefined) {
        localVarFormParams.append("offset", offset as any);
      }

      if (limit !== undefined) {
        localVarFormParams.append("limit", limit as any);
      }

      if (text !== undefined) {
        localVarFormParams.append("text", text as any);
      }

      if (image !== undefined) {
        localVarFormParams.append("image", image as any);
      }

      if (item !== undefined) {
        localVarFormParams.append("item", item as any);
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Prediction Search
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {boolean} desc
     * @param {string} [filters] Search Filters
     * @param {string} [orderBy]
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [text]
     * @param {File} [image]
     * @param {string} [item]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionSearch_4: async (
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      desc: boolean,
      filters?: string,
      orderBy?: string,
      offset?: number,
      limit?: number,
      text?: string,
      image?: File,
      item?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routePredictionSearch_4", "projectHash", projectHash);
      // verify required parameter 'predictionHash' is not null or undefined
      assertParamExists(
        "routePredictionSearch_4",
        "predictionHash",
        predictionHash
      );
      // verify required parameter 'domain' is not null or undefined
      assertParamExists("routePredictionSearch_4", "domain", domain);
      // verify required parameter 'iou' is not null or undefined
      assertParamExists("routePredictionSearch_4", "iou", iou);
      // verify required parameter 'desc' is not null or undefined
      assertParamExists("routePredictionSearch_4", "desc", desc);
      const localVarPath =
        `/api/projects_v2/{project_hash}/predictions/{prediction_hash}/analytics/{domain}/search`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(
            `{${"prediction_hash"}}`,
            encodeURIComponent(String(predictionHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)();

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      if (iou !== undefined) {
        localVarFormParams.append("iou", iou as any);
      }

      if (orderBy !== undefined) {
        localVarFormParams.append("order_by", orderBy as any);
      }

      if (desc !== undefined) {
        localVarFormParams.append("desc", desc as any);
      }

      if (offset !== undefined) {
        localVarFormParams.append("offset", offset as any);
      }

      if (limit !== undefined) {
        localVarFormParams.append("limit", limit as any);
      }

      if (text !== undefined) {
        localVarFormParams.append("text", text as any);
      }

      if (image !== undefined) {
        localVarFormParams.append("image", image as any);
      }

      if (item !== undefined) {
        localVarFormParams.append("item", item as any);
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Prediction Summary
     * @param {string} predictionHash
     * @param {string} projectHash
     * @param {number} iou
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionSummary: async (
      predictionHash: string,
      projectHash: string,
      iou: number,
      filters?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'predictionHash' is not null or undefined
      assertParamExists(
        "routePredictionSummary",
        "predictionHash",
        predictionHash
      );
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routePredictionSummary", "projectHash", projectHash);
      // verify required parameter 'iou' is not null or undefined
      assertParamExists("routePredictionSummary", "iou", iou);
      const localVarPath =
        `/api/projects_v2/{project_hash}/predictions/{prediction_hash}/summary`
          .replace(
            `{${"prediction_hash"}}`,
            encodeURIComponent(String(predictionHash))
          )
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (iou !== undefined) {
        localVarQueryParameter["iou"] = iou;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Update Tag
     * @param {string} projectHash
     * @param {string} tagHash
     * @param {ProjectTagRequest} projectTagRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeUpdateTag: async (
      projectHash: string,
      tagHash: string,
      projectTagRequest: ProjectTagRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeUpdateTag", "projectHash", projectHash);
      // verify required parameter 'tagHash' is not null or undefined
      assertParamExists("routeUpdateTag", "tagHash", tagHash);
      // verify required parameter 'projectTagRequest' is not null or undefined
      assertParamExists(
        "routeUpdateTag",
        "projectTagRequest",
        projectTagRequest
      );
      const localVarPath = `/api/projects_v2/{project_hash}/tags/{tag_hash}`
        .replace(`{${"project_hash"}}`, encodeURIComponent(String(projectHash)))
        .replace(`{${"tag_hash"}}`, encodeURIComponent(String(tagHash)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        projectTagRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PredictionApi - functional programming interface
 * @export
 */
export const PredictionApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    PredictionApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Route Create Tags
     * @param {string} projectHash
     * @param {Array<ProjectTagRequest>} projectTagRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeCreateTags(
      projectHash: string,
      projectTagRequest: Array<ProjectTagRequest>,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string | undefined }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.routeCreateTags(
        projectHash,
        projectTagRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Delete Tag
     * @param {string} projectHash
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeDeleteTag(
      projectHash: string,
      requestBody: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.routeDeleteTag(
        projectHash,
        requestBody,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Filter All Tags
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {SearchFilters} searchFilters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeFilterAllTags(
      projectHash: string,
      domain: AnalysisDomain,
      searchFilters: SearchFilters,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllTagsResult>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeFilterAllTags(
          projectHash,
          domain,
          searchFilters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Filter Tag All
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {BodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost} bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeFilterTagAll(
      projectHash: string,
      domain: AnalysisDomain,
      bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost: BodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeFilterTagAll(
          projectHash,
          domain,
          bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Filter Untag All
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {BodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost} bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeFilterUntagAll(
      projectHash: string,
      domain: AnalysisDomain,
      bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost: BodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeFilterUntagAll(
          projectHash,
          domain,
          bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Items All Tags
     * @param {string} projectHash
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeItemsAllTags(
      projectHash: string,
      requestBody: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllTagsResult>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeItemsAllTags(
          projectHash,
          requestBody,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Items Tag All
     * @param {string} projectHash
     * @param {BodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost} bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeItemsTagAll(
      projectHash: string,
      bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost: BodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeItemsTagAll(
          projectHash,
          bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Items Untag All
     * @param {string} projectHash
     * @param {BodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost} bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeItemsUntagAll(
      projectHash: string,
      bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost: BodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeItemsUntagAll(
          projectHash,
          bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route List Tags
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeListTags(
      projectHash: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ProjectTagEntry>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.routeListTags(
        projectHash,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route List Tags Meta
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeListTagsMeta(
      projectHash: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ProjectTagEntryMeta>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeListTagsMeta(projectHash, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Prediction Data Item
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {string} dataItem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routePredictionDataItem(
      projectHash: string,
      predictionHash: string,
      dataItem: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PredictionItem>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routePredictionDataItem(
          projectHash,
          predictionHash,
          dataItem,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Prediction Distribution
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {string} group
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routePredictionDistribution(
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      group: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<QueryDistribution>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routePredictionDistribution(
          projectHash,
          predictionHash,
          domain,
          iou,
          group,
          buckets,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Prediction Distribution
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {string} group
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routePredictionDistribution_1(
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      group: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<QueryDistribution>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routePredictionDistribution_1(
          projectHash,
          predictionHash,
          domain,
          iou,
          group,
          buckets,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Prediction Metric Performance
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {number} iou
     * @param {string} metricName
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routePredictionMetricPerformance(
      projectHash: string,
      predictionHash: string,
      iou: number,
      metricName: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<QueryMetricPerformance>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routePredictionMetricPerformance(
          projectHash,
          predictionHash,
          iou,
          metricName,
          buckets,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Prediction Reduction Scatter
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {string} reductionHash
     * @param {number} iou
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routePredictionReductionScatter(
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      reductionHash: string,
      iou: number,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PredictionQuery2DEmbedding>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routePredictionReductionScatter(
          projectHash,
          predictionHash,
          domain,
          reductionHash,
          iou,
          buckets,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Prediction Reduction Scatter
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {string} reductionHash
     * @param {number} iou
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routePredictionReductionScatter_2(
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      reductionHash: string,
      iou: number,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PredictionQuery2DEmbedding>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routePredictionReductionScatter_2(
          projectHash,
          predictionHash,
          domain,
          reductionHash,
          iou,
          buckets,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Prediction Scatter
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {string} xMetric
     * @param {string} yMetric
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routePredictionScatter(
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      xMetric: string,
      yMetric: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryScatter>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routePredictionScatter(
          projectHash,
          predictionHash,
          domain,
          iou,
          xMetric,
          yMetric,
          buckets,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Prediction Scatter
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {string} xMetric
     * @param {string} yMetric
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routePredictionScatter_3(
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      xMetric: string,
      yMetric: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryScatter>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routePredictionScatter_3(
          projectHash,
          predictionHash,
          domain,
          iou,
          xMetric,
          yMetric,
          buckets,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Prediction Search
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {boolean} desc
     * @param {string} [filters] Search Filters
     * @param {string} [orderBy]
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [text]
     * @param {File} [image]
     * @param {string} [item]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routePredictionSearch(
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      desc: boolean,
      filters?: string,
      orderBy?: string,
      offset?: number,
      limit?: number,
      text?: string,
      image?: File,
      item?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalysisSearch>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routePredictionSearch(
          projectHash,
          predictionHash,
          domain,
          iou,
          desc,
          filters,
          orderBy,
          offset,
          limit,
          text,
          image,
          item,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Prediction Search
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {boolean} desc
     * @param {string} [filters] Search Filters
     * @param {string} [orderBy]
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [text]
     * @param {File} [image]
     * @param {string} [item]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routePredictionSearch_4(
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      desc: boolean,
      filters?: string,
      orderBy?: string,
      offset?: number,
      limit?: number,
      text?: string,
      image?: File,
      item?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalysisSearch>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routePredictionSearch_4(
          projectHash,
          predictionHash,
          domain,
          iou,
          desc,
          filters,
          orderBy,
          offset,
          limit,
          text,
          image,
          item,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Prediction Summary
     * @param {string} predictionHash
     * @param {string} projectHash
     * @param {number} iou
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routePredictionSummary(
      predictionHash: string,
      projectHash: string,
      iou: number,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PredictionSummaryResult>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routePredictionSummary(
          predictionHash,
          projectHash,
          iou,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Update Tag
     * @param {string} projectHash
     * @param {string} tagHash
     * @param {ProjectTagRequest} projectTagRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeUpdateTag(
      projectHash: string,
      tagHash: string,
      projectTagRequest: ProjectTagRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.routeUpdateTag(
        projectHash,
        tagHash,
        projectTagRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * PredictionApi - factory interface
 * @export
 */
export const PredictionApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PredictionApiFp(configuration);
  return {
    /**
     *
     * @summary Route Create Tags
     * @param {string} projectHash
     * @param {Array<ProjectTagRequest>} projectTagRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeCreateTags(
      projectHash: string,
      projectTagRequest: Array<ProjectTagRequest>,
      options?: any
    ): AxiosPromise<{ [key: string]: string | undefined }> {
      return localVarFp
        .routeCreateTags(projectHash, projectTagRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Delete Tag
     * @param {string} projectHash
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeDeleteTag(
      projectHash: string,
      requestBody: Array<string>,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .routeDeleteTag(projectHash, requestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Filter All Tags
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {SearchFilters} searchFilters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeFilterAllTags(
      projectHash: string,
      domain: AnalysisDomain,
      searchFilters: SearchFilters,
      options?: any
    ): AxiosPromise<AllTagsResult> {
      return localVarFp
        .routeFilterAllTags(projectHash, domain, searchFilters, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Filter Tag All
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {BodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost} bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeFilterTagAll(
      projectHash: string,
      domain: AnalysisDomain,
      bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost: BodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .routeFilterTagAll(
          projectHash,
          domain,
          bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Filter Untag All
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {BodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost} bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeFilterUntagAll(
      projectHash: string,
      domain: AnalysisDomain,
      bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost: BodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .routeFilterUntagAll(
          projectHash,
          domain,
          bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Items All Tags
     * @param {string} projectHash
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeItemsAllTags(
      projectHash: string,
      requestBody: Array<string>,
      options?: any
    ): AxiosPromise<AllTagsResult> {
      return localVarFp
        .routeItemsAllTags(projectHash, requestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Items Tag All
     * @param {string} projectHash
     * @param {BodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost} bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeItemsTagAll(
      projectHash: string,
      bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost: BodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .routeItemsTagAll(
          projectHash,
          bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Items Untag All
     * @param {string} projectHash
     * @param {BodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost} bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeItemsUntagAll(
      projectHash: string,
      bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost: BodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .routeItemsUntagAll(
          projectHash,
          bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route List Tags
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeListTags(
      projectHash: string,
      options?: any
    ): AxiosPromise<Array<ProjectTagEntry>> {
      return localVarFp
        .routeListTags(projectHash, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route List Tags Meta
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeListTagsMeta(
      projectHash: string,
      options?: any
    ): AxiosPromise<Array<ProjectTagEntryMeta>> {
      return localVarFp
        .routeListTagsMeta(projectHash, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Prediction Data Item
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {string} dataItem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionDataItem(
      projectHash: string,
      predictionHash: string,
      dataItem: string,
      options?: any
    ): AxiosPromise<PredictionItem> {
      return localVarFp
        .routePredictionDataItem(projectHash, predictionHash, dataItem, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Prediction Distribution
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {string} group
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionDistribution(
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      group: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: any
    ): AxiosPromise<QueryDistribution> {
      return localVarFp
        .routePredictionDistribution(
          projectHash,
          predictionHash,
          domain,
          iou,
          group,
          buckets,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Prediction Distribution
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {string} group
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionDistribution_1(
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      group: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: any
    ): AxiosPromise<QueryDistribution> {
      return localVarFp
        .routePredictionDistribution_1(
          projectHash,
          predictionHash,
          domain,
          iou,
          group,
          buckets,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Prediction Metric Performance
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {number} iou
     * @param {string} metricName
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionMetricPerformance(
      projectHash: string,
      predictionHash: string,
      iou: number,
      metricName: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: any
    ): AxiosPromise<QueryMetricPerformance> {
      return localVarFp
        .routePredictionMetricPerformance(
          projectHash,
          predictionHash,
          iou,
          metricName,
          buckets,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Prediction Reduction Scatter
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {string} reductionHash
     * @param {number} iou
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionReductionScatter(
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      reductionHash: string,
      iou: number,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: any
    ): AxiosPromise<PredictionQuery2DEmbedding> {
      return localVarFp
        .routePredictionReductionScatter(
          projectHash,
          predictionHash,
          domain,
          reductionHash,
          iou,
          buckets,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Prediction Reduction Scatter
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {string} reductionHash
     * @param {number} iou
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionReductionScatter_2(
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      reductionHash: string,
      iou: number,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: any
    ): AxiosPromise<PredictionQuery2DEmbedding> {
      return localVarFp
        .routePredictionReductionScatter_2(
          projectHash,
          predictionHash,
          domain,
          reductionHash,
          iou,
          buckets,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Prediction Scatter
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {string} xMetric
     * @param {string} yMetric
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionScatter(
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      xMetric: string,
      yMetric: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: any
    ): AxiosPromise<QueryScatter> {
      return localVarFp
        .routePredictionScatter(
          projectHash,
          predictionHash,
          domain,
          iou,
          xMetric,
          yMetric,
          buckets,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Prediction Scatter
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {string} xMetric
     * @param {string} yMetric
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionScatter_3(
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      xMetric: string,
      yMetric: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: any
    ): AxiosPromise<QueryScatter> {
      return localVarFp
        .routePredictionScatter_3(
          projectHash,
          predictionHash,
          domain,
          iou,
          xMetric,
          yMetric,
          buckets,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Prediction Search
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {boolean} desc
     * @param {string} [filters] Search Filters
     * @param {string} [orderBy]
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [text]
     * @param {File} [image]
     * @param {string} [item]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionSearch(
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      desc: boolean,
      filters?: string,
      orderBy?: string,
      offset?: number,
      limit?: number,
      text?: string,
      image?: File,
      item?: string,
      options?: any
    ): AxiosPromise<AnalysisSearch> {
      return localVarFp
        .routePredictionSearch(
          projectHash,
          predictionHash,
          domain,
          iou,
          desc,
          filters,
          orderBy,
          offset,
          limit,
          text,
          image,
          item,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Prediction Search
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {boolean} desc
     * @param {string} [filters] Search Filters
     * @param {string} [orderBy]
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [text]
     * @param {File} [image]
     * @param {string} [item]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionSearch_4(
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      desc: boolean,
      filters?: string,
      orderBy?: string,
      offset?: number,
      limit?: number,
      text?: string,
      image?: File,
      item?: string,
      options?: any
    ): AxiosPromise<AnalysisSearch> {
      return localVarFp
        .routePredictionSearch_4(
          projectHash,
          predictionHash,
          domain,
          iou,
          desc,
          filters,
          orderBy,
          offset,
          limit,
          text,
          image,
          item,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Prediction Summary
     * @param {string} predictionHash
     * @param {string} projectHash
     * @param {number} iou
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionSummary(
      predictionHash: string,
      projectHash: string,
      iou: number,
      filters?: string,
      options?: any
    ): AxiosPromise<PredictionSummaryResult> {
      return localVarFp
        .routePredictionSummary(
          predictionHash,
          projectHash,
          iou,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Update Tag
     * @param {string} projectHash
     * @param {string} tagHash
     * @param {ProjectTagRequest} projectTagRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeUpdateTag(
      projectHash: string,
      tagHash: string,
      projectTagRequest: ProjectTagRequest,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .routeUpdateTag(projectHash, tagHash, projectTagRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PredictionApi - object-oriented interface
 * @export
 * @class PredictionApi
 * @extends {BaseAPI}
 */
export class PredictionApi extends BaseAPI {
  /**
   *
   * @summary Route Create Tags
   * @param {string} projectHash
   * @param {Array<ProjectTagRequest>} projectTagRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PredictionApi
   */
  public routeCreateTags(
    projectHash: string,
    projectTagRequest: Array<ProjectTagRequest>,
    options?: AxiosRequestConfig
  ) {
    return PredictionApiFp(this.configuration)
      .routeCreateTags(projectHash, projectTagRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Delete Tag
   * @param {string} projectHash
   * @param {Array<string>} requestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PredictionApi
   */
  public routeDeleteTag(
    projectHash: string,
    requestBody: Array<string>,
    options?: AxiosRequestConfig
  ) {
    return PredictionApiFp(this.configuration)
      .routeDeleteTag(projectHash, requestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Filter All Tags
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {SearchFilters} searchFilters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PredictionApi
   */
  public routeFilterAllTags(
    projectHash: string,
    domain: AnalysisDomain,
    searchFilters: SearchFilters,
    options?: AxiosRequestConfig
  ) {
    return PredictionApiFp(this.configuration)
      .routeFilterAllTags(projectHash, domain, searchFilters, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Filter Tag All
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {BodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost} bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PredictionApi
   */
  public routeFilterTagAll(
    projectHash: string,
    domain: AnalysisDomain,
    bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost: BodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost,
    options?: AxiosRequestConfig
  ) {
    return PredictionApiFp(this.configuration)
      .routeFilterTagAll(
        projectHash,
        domain,
        bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Filter Untag All
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {BodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost} bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PredictionApi
   */
  public routeFilterUntagAll(
    projectHash: string,
    domain: AnalysisDomain,
    bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost: BodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost,
    options?: AxiosRequestConfig
  ) {
    return PredictionApiFp(this.configuration)
      .routeFilterUntagAll(
        projectHash,
        domain,
        bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Items All Tags
   * @param {string} projectHash
   * @param {Array<string>} requestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PredictionApi
   */
  public routeItemsAllTags(
    projectHash: string,
    requestBody: Array<string>,
    options?: AxiosRequestConfig
  ) {
    return PredictionApiFp(this.configuration)
      .routeItemsAllTags(projectHash, requestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Items Tag All
   * @param {string} projectHash
   * @param {BodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost} bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PredictionApi
   */
  public routeItemsTagAll(
    projectHash: string,
    bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost: BodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost,
    options?: AxiosRequestConfig
  ) {
    return PredictionApiFp(this.configuration)
      .routeItemsTagAll(
        projectHash,
        bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Items Untag All
   * @param {string} projectHash
   * @param {BodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost} bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PredictionApi
   */
  public routeItemsUntagAll(
    projectHash: string,
    bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost: BodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost,
    options?: AxiosRequestConfig
  ) {
    return PredictionApiFp(this.configuration)
      .routeItemsUntagAll(
        projectHash,
        bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route List Tags
   * @param {string} projectHash
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PredictionApi
   */
  public routeListTags(projectHash: string, options?: AxiosRequestConfig) {
    return PredictionApiFp(this.configuration)
      .routeListTags(projectHash, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route List Tags Meta
   * @param {string} projectHash
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PredictionApi
   */
  public routeListTagsMeta(projectHash: string, options?: AxiosRequestConfig) {
    return PredictionApiFp(this.configuration)
      .routeListTagsMeta(projectHash, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Prediction Data Item
   * @param {string} projectHash
   * @param {string} predictionHash
   * @param {string} dataItem
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PredictionApi
   */
  public routePredictionDataItem(
    projectHash: string,
    predictionHash: string,
    dataItem: string,
    options?: AxiosRequestConfig
  ) {
    return PredictionApiFp(this.configuration)
      .routePredictionDataItem(projectHash, predictionHash, dataItem, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Prediction Distribution
   * @param {string} projectHash
   * @param {string} predictionHash
   * @param {PredictionDomain} domain
   * @param {number} iou
   * @param {string} group
   * @param {AnalysisBuckets} [buckets]
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PredictionApi
   */
  public routePredictionDistribution(
    projectHash: string,
    predictionHash: string,
    domain: PredictionDomain,
    iou: number,
    group: string,
    buckets?: AnalysisBuckets,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return PredictionApiFp(this.configuration)
      .routePredictionDistribution(
        projectHash,
        predictionHash,
        domain,
        iou,
        group,
        buckets,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Prediction Distribution
   * @param {string} projectHash
   * @param {string} predictionHash
   * @param {PredictionDomain} domain
   * @param {number} iou
   * @param {string} group
   * @param {AnalysisBuckets} [buckets]
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PredictionApi
   */
  public routePredictionDistribution_1(
    projectHash: string,
    predictionHash: string,
    domain: PredictionDomain,
    iou: number,
    group: string,
    buckets?: AnalysisBuckets,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return PredictionApiFp(this.configuration)
      .routePredictionDistribution_1(
        projectHash,
        predictionHash,
        domain,
        iou,
        group,
        buckets,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Prediction Metric Performance
   * @param {string} projectHash
   * @param {string} predictionHash
   * @param {number} iou
   * @param {string} metricName
   * @param {AnalysisBuckets} [buckets]
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PredictionApi
   */
  public routePredictionMetricPerformance(
    projectHash: string,
    predictionHash: string,
    iou: number,
    metricName: string,
    buckets?: AnalysisBuckets,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return PredictionApiFp(this.configuration)
      .routePredictionMetricPerformance(
        projectHash,
        predictionHash,
        iou,
        metricName,
        buckets,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Prediction Reduction Scatter
   * @param {string} projectHash
   * @param {string} predictionHash
   * @param {PredictionDomain} domain
   * @param {string} reductionHash
   * @param {number} iou
   * @param {AnalysisBuckets} [buckets]
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PredictionApi
   */
  public routePredictionReductionScatter(
    projectHash: string,
    predictionHash: string,
    domain: PredictionDomain,
    reductionHash: string,
    iou: number,
    buckets?: AnalysisBuckets,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return PredictionApiFp(this.configuration)
      .routePredictionReductionScatter(
        projectHash,
        predictionHash,
        domain,
        reductionHash,
        iou,
        buckets,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Prediction Reduction Scatter
   * @param {string} projectHash
   * @param {string} predictionHash
   * @param {PredictionDomain} domain
   * @param {string} reductionHash
   * @param {number} iou
   * @param {AnalysisBuckets} [buckets]
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PredictionApi
   */
  public routePredictionReductionScatter_2(
    projectHash: string,
    predictionHash: string,
    domain: PredictionDomain,
    reductionHash: string,
    iou: number,
    buckets?: AnalysisBuckets,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return PredictionApiFp(this.configuration)
      .routePredictionReductionScatter_2(
        projectHash,
        predictionHash,
        domain,
        reductionHash,
        iou,
        buckets,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Prediction Scatter
   * @param {string} projectHash
   * @param {string} predictionHash
   * @param {PredictionDomain} domain
   * @param {number} iou
   * @param {string} xMetric
   * @param {string} yMetric
   * @param {AnalysisBuckets} [buckets]
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PredictionApi
   */
  public routePredictionScatter(
    projectHash: string,
    predictionHash: string,
    domain: PredictionDomain,
    iou: number,
    xMetric: string,
    yMetric: string,
    buckets?: AnalysisBuckets,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return PredictionApiFp(this.configuration)
      .routePredictionScatter(
        projectHash,
        predictionHash,
        domain,
        iou,
        xMetric,
        yMetric,
        buckets,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Prediction Scatter
   * @param {string} projectHash
   * @param {string} predictionHash
   * @param {PredictionDomain} domain
   * @param {number} iou
   * @param {string} xMetric
   * @param {string} yMetric
   * @param {AnalysisBuckets} [buckets]
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PredictionApi
   */
  public routePredictionScatter_3(
    projectHash: string,
    predictionHash: string,
    domain: PredictionDomain,
    iou: number,
    xMetric: string,
    yMetric: string,
    buckets?: AnalysisBuckets,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return PredictionApiFp(this.configuration)
      .routePredictionScatter_3(
        projectHash,
        predictionHash,
        domain,
        iou,
        xMetric,
        yMetric,
        buckets,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Prediction Search
   * @param {string} projectHash
   * @param {string} predictionHash
   * @param {PredictionDomain} domain
   * @param {number} iou
   * @param {boolean} desc
   * @param {string} [filters] Search Filters
   * @param {string} [orderBy]
   * @param {number} [offset]
   * @param {number} [limit]
   * @param {string} [text]
   * @param {File} [image]
   * @param {string} [item]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PredictionApi
   */
  public routePredictionSearch(
    projectHash: string,
    predictionHash: string,
    domain: PredictionDomain,
    iou: number,
    desc: boolean,
    filters?: string,
    orderBy?: string,
    offset?: number,
    limit?: number,
    text?: string,
    image?: File,
    item?: string,
    options?: AxiosRequestConfig
  ) {
    return PredictionApiFp(this.configuration)
      .routePredictionSearch(
        projectHash,
        predictionHash,
        domain,
        iou,
        desc,
        filters,
        orderBy,
        offset,
        limit,
        text,
        image,
        item,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Prediction Search
   * @param {string} projectHash
   * @param {string} predictionHash
   * @param {PredictionDomain} domain
   * @param {number} iou
   * @param {boolean} desc
   * @param {string} [filters] Search Filters
   * @param {string} [orderBy]
   * @param {number} [offset]
   * @param {number} [limit]
   * @param {string} [text]
   * @param {File} [image]
   * @param {string} [item]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PredictionApi
   */
  public routePredictionSearch_4(
    projectHash: string,
    predictionHash: string,
    domain: PredictionDomain,
    iou: number,
    desc: boolean,
    filters?: string,
    orderBy?: string,
    offset?: number,
    limit?: number,
    text?: string,
    image?: File,
    item?: string,
    options?: AxiosRequestConfig
  ) {
    return PredictionApiFp(this.configuration)
      .routePredictionSearch_4(
        projectHash,
        predictionHash,
        domain,
        iou,
        desc,
        filters,
        orderBy,
        offset,
        limit,
        text,
        image,
        item,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Prediction Summary
   * @param {string} predictionHash
   * @param {string} projectHash
   * @param {number} iou
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PredictionApi
   */
  public routePredictionSummary(
    predictionHash: string,
    projectHash: string,
    iou: number,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return PredictionApiFp(this.configuration)
      .routePredictionSummary(
        predictionHash,
        projectHash,
        iou,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Update Tag
   * @param {string} projectHash
   * @param {string} tagHash
   * @param {ProjectTagRequest} projectTagRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PredictionApi
   */
  public routeUpdateTag(
    projectHash: string,
    tagHash: string,
    projectTagRequest: ProjectTagRequest,
    options?: AxiosRequestConfig
  ) {
    return PredictionApiFp(this.configuration)
      .routeUpdateTag(projectHash, tagHash, projectTagRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ProjectApi - axios parameter creator
 * @export
 */
export const ProjectApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Route Action Create Project Subset
     * @param {string} projectHash
     * @param {CreateProjectSubsetPostAction} createProjectSubsetPostAction
     * @param {boolean} [remoteOnly]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeActionCreateProjectSubset: async (
      projectHash: string,
      createProjectSubsetPostAction: CreateProjectSubsetPostAction,
      remoteOnly?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routeActionCreateProjectSubset",
        "projectHash",
        projectHash
      );
      // verify required parameter 'createProjectSubsetPostAction' is not null or undefined
      assertParamExists(
        "routeActionCreateProjectSubset",
        "createProjectSubsetPostAction",
        createProjectSubsetPostAction
      );
      const localVarPath =
        `/api/projects_v2/{project_hash}/actions/create_project_subset`.replace(
          `{${"project_hash"}}`,
          encodeURIComponent(String(projectHash))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (remoteOnly !== undefined) {
        localVarQueryParameter["remote_only"] = remoteOnly;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createProjectSubsetPostAction,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Action Create Project Subset
     * @param {string} projectHash
     * @param {CreateProjectSubsetPostAction} createProjectSubsetPostAction
     * @param {boolean} [remoteOnly]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeActionCreateProjectSubset_1: async (
      projectHash: string,
      createProjectSubsetPostAction: CreateProjectSubsetPostAction,
      remoteOnly?: boolean,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routeActionCreateProjectSubset_1",
        "projectHash",
        projectHash
      );
      // verify required parameter 'createProjectSubsetPostAction' is not null or undefined
      assertParamExists(
        "routeActionCreateProjectSubset_1",
        "createProjectSubsetPostAction",
        createProjectSubsetPostAction
      );
      const localVarPath =
        `/api/projects_v2/{project_hash}/actions/create_project_subset`.replace(
          `{${"project_hash"}}`,
          encodeURIComponent(String(projectHash))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (remoteOnly !== undefined) {
        localVarQueryParameter["remote_only"] = remoteOnly;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createProjectSubsetPostAction,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Action Upload Project To Encord
     * @param {string} projectHash
     * @param {UploadProjectToEncordPostAction} uploadProjectToEncordPostAction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeActionUploadProjectToEncord: async (
      projectHash: string,
      uploadProjectToEncordPostAction: UploadProjectToEncordPostAction,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routeActionUploadProjectToEncord",
        "projectHash",
        projectHash
      );
      // verify required parameter 'uploadProjectToEncordPostAction' is not null or undefined
      assertParamExists(
        "routeActionUploadProjectToEncord",
        "uploadProjectToEncordPostAction",
        uploadProjectToEncordPostAction
      );
      const localVarPath =
        `/api/projects_v2/{project_hash}/actions/upload_to_encord`.replace(
          `{${"project_hash"}}`,
          encodeURIComponent(String(projectHash))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        uploadProjectToEncordPostAction,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Action Upload Project To Encord
     * @param {string} projectHash
     * @param {UploadProjectToEncordPostAction} uploadProjectToEncordPostAction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeActionUploadProjectToEncord_2: async (
      projectHash: string,
      uploadProjectToEncordPostAction: UploadProjectToEncordPostAction,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routeActionUploadProjectToEncord_2",
        "projectHash",
        projectHash
      );
      // verify required parameter 'uploadProjectToEncordPostAction' is not null or undefined
      assertParamExists(
        "routeActionUploadProjectToEncord_2",
        "uploadProjectToEncordPostAction",
        uploadProjectToEncordPostAction
      );
      const localVarPath =
        `/api/projects_v2/{project_hash}/actions/upload_to_encord`.replace(
          `{${"project_hash"}}`,
          encodeURIComponent(String(projectHash))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        uploadProjectToEncordPostAction,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Create Tags
     * @param {string} projectHash
     * @param {Array<ProjectTagRequest>} projectTagRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeCreateTags: async (
      projectHash: string,
      projectTagRequest: Array<ProjectTagRequest>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeCreateTags", "projectHash", projectHash);
      // verify required parameter 'projectTagRequest' is not null or undefined
      assertParamExists(
        "routeCreateTags",
        "projectTagRequest",
        projectTagRequest
      );
      const localVarPath = `/api/projects_v2/{project_hash}/tags/`.replace(
        `{${"project_hash"}}`,
        encodeURIComponent(String(projectHash))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        projectTagRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Create Tags
     * @param {string} projectHash
     * @param {Array<ProjectTagRequest>} projectTagRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeCreateTags_3: async (
      projectHash: string,
      projectTagRequest: Array<ProjectTagRequest>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeCreateTags_3", "projectHash", projectHash);
      // verify required parameter 'projectTagRequest' is not null or undefined
      assertParamExists(
        "routeCreateTags_3",
        "projectTagRequest",
        projectTagRequest
      );
      const localVarPath = `/api/projects_v2/{project_hash}/tags/`.replace(
        `{${"project_hash"}}`,
        encodeURIComponent(String(projectHash))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        projectTagRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Delete Tag
     * @param {string} projectHash
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeDeleteTag: async (
      projectHash: string,
      requestBody: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeDeleteTag", "projectHash", projectHash);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("routeDeleteTag", "requestBody", requestBody);
      const localVarPath = `/api/projects_v2/{project_hash}/tags/`.replace(
        `{${"project_hash"}}`,
        encodeURIComponent(String(projectHash))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Delete Tag
     * @param {string} projectHash
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeDeleteTag_4: async (
      projectHash: string,
      requestBody: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeDeleteTag_4", "projectHash", projectHash);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("routeDeleteTag_4", "requestBody", requestBody);
      const localVarPath = `/api/projects_v2/{project_hash}/tags/`.replace(
        `{${"project_hash"}}`,
        encodeURIComponent(String(projectHash))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Filter All Tags
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {SearchFilters} searchFilters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeFilterAllTags: async (
      projectHash: string,
      domain: AnalysisDomain,
      searchFilters: SearchFilters,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeFilterAllTags", "projectHash", projectHash);
      // verify required parameter 'domain' is not null or undefined
      assertParamExists("routeFilterAllTags", "domain", domain);
      // verify required parameter 'searchFilters' is not null or undefined
      assertParamExists("routeFilterAllTags", "searchFilters", searchFilters);
      const localVarPath =
        `/api/projects_v2/{project_hash}/tags/{domain}/filter/all_tags`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        searchFilters,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Filter All Tags
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {SearchFilters} searchFilters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeFilterAllTags_5: async (
      projectHash: string,
      domain: AnalysisDomain,
      searchFilters: SearchFilters,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeFilterAllTags_5", "projectHash", projectHash);
      // verify required parameter 'domain' is not null or undefined
      assertParamExists("routeFilterAllTags_5", "domain", domain);
      // verify required parameter 'searchFilters' is not null or undefined
      assertParamExists("routeFilterAllTags_5", "searchFilters", searchFilters);
      const localVarPath =
        `/api/projects_v2/{project_hash}/tags/{domain}/filter/all_tags`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        searchFilters,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Filter Tag All
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {BodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost} bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeFilterTagAll: async (
      projectHash: string,
      domain: AnalysisDomain,
      bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost: BodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeFilterTagAll", "projectHash", projectHash);
      // verify required parameter 'domain' is not null or undefined
      assertParamExists("routeFilterTagAll", "domain", domain);
      // verify required parameter 'bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost' is not null or undefined
      assertParamExists(
        "routeFilterTagAll",
        "bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost",
        bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost
      );
      const localVarPath =
        `/api/projects_v2/{project_hash}/tags/{domain}/filter/tag_all`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Filter Tag All
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {BodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost} bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeFilterTagAll_6: async (
      projectHash: string,
      domain: AnalysisDomain,
      bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost: BodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeFilterTagAll_6", "projectHash", projectHash);
      // verify required parameter 'domain' is not null or undefined
      assertParamExists("routeFilterTagAll_6", "domain", domain);
      // verify required parameter 'bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost' is not null or undefined
      assertParamExists(
        "routeFilterTagAll_6",
        "bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost",
        bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost
      );
      const localVarPath =
        `/api/projects_v2/{project_hash}/tags/{domain}/filter/tag_all`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Filter Untag All
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {BodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost} bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeFilterUntagAll: async (
      projectHash: string,
      domain: AnalysisDomain,
      bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost: BodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeFilterUntagAll", "projectHash", projectHash);
      // verify required parameter 'domain' is not null or undefined
      assertParamExists("routeFilterUntagAll", "domain", domain);
      // verify required parameter 'bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost' is not null or undefined
      assertParamExists(
        "routeFilterUntagAll",
        "bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost",
        bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost
      );
      const localVarPath =
        `/api/projects_v2/{project_hash}/tags/{domain}/filter/untag_all`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Filter Untag All
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {BodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost} bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeFilterUntagAll_7: async (
      projectHash: string,
      domain: AnalysisDomain,
      bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost: BodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeFilterUntagAll_7", "projectHash", projectHash);
      // verify required parameter 'domain' is not null or undefined
      assertParamExists("routeFilterUntagAll_7", "domain", domain);
      // verify required parameter 'bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost' is not null or undefined
      assertParamExists(
        "routeFilterUntagAll_7",
        "bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost",
        bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost
      );
      const localVarPath =
        `/api/projects_v2/{project_hash}/tags/{domain}/filter/untag_all`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Items All Tags
     * @param {string} projectHash
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeItemsAllTags: async (
      projectHash: string,
      requestBody: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeItemsAllTags", "projectHash", projectHash);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("routeItemsAllTags", "requestBody", requestBody);
      const localVarPath =
        `/api/projects_v2/{project_hash}/tags/items/all_tags`.replace(
          `{${"project_hash"}}`,
          encodeURIComponent(String(projectHash))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Items All Tags
     * @param {string} projectHash
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeItemsAllTags_8: async (
      projectHash: string,
      requestBody: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeItemsAllTags_8", "projectHash", projectHash);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists("routeItemsAllTags_8", "requestBody", requestBody);
      const localVarPath =
        `/api/projects_v2/{project_hash}/tags/items/all_tags`.replace(
          `{${"project_hash"}}`,
          encodeURIComponent(String(projectHash))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Items Tag All
     * @param {string} projectHash
     * @param {BodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost} bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeItemsTagAll: async (
      projectHash: string,
      bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost: BodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeItemsTagAll", "projectHash", projectHash);
      // verify required parameter 'bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost' is not null or undefined
      assertParamExists(
        "routeItemsTagAll",
        "bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost",
        bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost
      );
      const localVarPath =
        `/api/projects_v2/{project_hash}/tags/items/tag_all`.replace(
          `{${"project_hash"}}`,
          encodeURIComponent(String(projectHash))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Items Tag All
     * @param {string} projectHash
     * @param {BodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost} bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeItemsTagAll_9: async (
      projectHash: string,
      bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost: BodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeItemsTagAll_9", "projectHash", projectHash);
      // verify required parameter 'bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost' is not null or undefined
      assertParamExists(
        "routeItemsTagAll_9",
        "bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost",
        bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost
      );
      const localVarPath =
        `/api/projects_v2/{project_hash}/tags/items/tag_all`.replace(
          `{${"project_hash"}}`,
          encodeURIComponent(String(projectHash))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Items Untag All
     * @param {string} projectHash
     * @param {BodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost} bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeItemsUntagAll: async (
      projectHash: string,
      bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost: BodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeItemsUntagAll", "projectHash", projectHash);
      // verify required parameter 'bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost' is not null or undefined
      assertParamExists(
        "routeItemsUntagAll",
        "bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost",
        bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost
      );
      const localVarPath =
        `/api/projects_v2/{project_hash}/tags/items/untag_all`.replace(
          `{${"project_hash"}}`,
          encodeURIComponent(String(projectHash))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Items Untag All
     * @param {string} projectHash
     * @param {BodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost} bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeItemsUntagAll_10: async (
      projectHash: string,
      bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost: BodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeItemsUntagAll_10", "projectHash", projectHash);
      // verify required parameter 'bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost' is not null or undefined
      assertParamExists(
        "routeItemsUntagAll_10",
        "bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost",
        bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost
      );
      const localVarPath =
        `/api/projects_v2/{project_hash}/tags/items/untag_all`.replace(
          `{${"project_hash"}}`,
          encodeURIComponent(String(projectHash))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route List Projects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeListProjects: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/projects_v2`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route List Tags
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeListTags: async (
      projectHash: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeListTags", "projectHash", projectHash);
      const localVarPath = `/api/projects_v2/{project_hash}/tags/`.replace(
        `{${"project_hash"}}`,
        encodeURIComponent(String(projectHash))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route List Tags Meta
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeListTagsMeta: async (
      projectHash: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeListTagsMeta", "projectHash", projectHash);
      const localVarPath = `/api/projects_v2/{project_hash}/tags/meta`.replace(
        `{${"project_hash"}}`,
        encodeURIComponent(String(projectHash))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route List Tags Meta
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeListTagsMeta_11: async (
      projectHash: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeListTagsMeta_11", "projectHash", projectHash);
      const localVarPath = `/api/projects_v2/{project_hash}/tags/meta`.replace(
        `{${"project_hash"}}`,
        encodeURIComponent(String(projectHash))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route List Tags
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeListTags_12: async (
      projectHash: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeListTags_12", "projectHash", projectHash);
      const localVarPath = `/api/projects_v2/{project_hash}/tags/`.replace(
        `{${"project_hash"}}`,
        encodeURIComponent(String(projectHash))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Prediction Data Item
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {string} dataItem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionDataItem: async (
      projectHash: string,
      predictionHash: string,
      dataItem: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routePredictionDataItem", "projectHash", projectHash);
      // verify required parameter 'predictionHash' is not null or undefined
      assertParamExists(
        "routePredictionDataItem",
        "predictionHash",
        predictionHash
      );
      // verify required parameter 'dataItem' is not null or undefined
      assertParamExists("routePredictionDataItem", "dataItem", dataItem);
      const localVarPath =
        `/api/projects_v2/{project_hash}/predictions/{prediction_hash}/preview/{data_item}`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(
            `{${"prediction_hash"}}`,
            encodeURIComponent(String(predictionHash))
          )
          .replace(`{${"data_item"}}`, encodeURIComponent(String(dataItem)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Prediction Distribution
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {string} group
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionDistribution: async (
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      group: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routePredictionDistribution",
        "projectHash",
        projectHash
      );
      // verify required parameter 'predictionHash' is not null or undefined
      assertParamExists(
        "routePredictionDistribution",
        "predictionHash",
        predictionHash
      );
      // verify required parameter 'domain' is not null or undefined
      assertParamExists("routePredictionDistribution", "domain", domain);
      // verify required parameter 'iou' is not null or undefined
      assertParamExists("routePredictionDistribution", "iou", iou);
      // verify required parameter 'group' is not null or undefined
      assertParamExists("routePredictionDistribution", "group", group);
      const localVarPath =
        `/api/projects_v2/{project_hash}/predictions/{prediction_hash}/analytics/{domain}/distribution`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(
            `{${"prediction_hash"}}`,
            encodeURIComponent(String(predictionHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (iou !== undefined) {
        localVarQueryParameter["iou"] = iou;
      }

      if (group !== undefined) {
        localVarQueryParameter["group"] = group;
      }

      if (buckets !== undefined) {
        localVarQueryParameter["buckets"] = buckets;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Prediction Metric Performance
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {number} iou
     * @param {string} metricName
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionMetricPerformance: async (
      projectHash: string,
      predictionHash: string,
      iou: number,
      metricName: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routePredictionMetricPerformance",
        "projectHash",
        projectHash
      );
      // verify required parameter 'predictionHash' is not null or undefined
      assertParamExists(
        "routePredictionMetricPerformance",
        "predictionHash",
        predictionHash
      );
      // verify required parameter 'iou' is not null or undefined
      assertParamExists("routePredictionMetricPerformance", "iou", iou);
      // verify required parameter 'metricName' is not null or undefined
      assertParamExists(
        "routePredictionMetricPerformance",
        "metricName",
        metricName
      );
      const localVarPath =
        `/api/projects_v2/{project_hash}/predictions/{prediction_hash}/metric_performance`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(
            `{${"prediction_hash"}}`,
            encodeURIComponent(String(predictionHash))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (iou !== undefined) {
        localVarQueryParameter["iou"] = iou;
      }

      if (metricName !== undefined) {
        localVarQueryParameter["metric_name"] = metricName;
      }

      if (buckets !== undefined) {
        localVarQueryParameter["buckets"] = buckets;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Prediction Reduction Scatter
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {string} reductionHash
     * @param {number} iou
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionReductionScatter: async (
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      reductionHash: string,
      iou: number,
      buckets?: AnalysisBuckets,
      filters?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routePredictionReductionScatter",
        "projectHash",
        projectHash
      );
      // verify required parameter 'predictionHash' is not null or undefined
      assertParamExists(
        "routePredictionReductionScatter",
        "predictionHash",
        predictionHash
      );
      // verify required parameter 'domain' is not null or undefined
      assertParamExists("routePredictionReductionScatter", "domain", domain);
      // verify required parameter 'reductionHash' is not null or undefined
      assertParamExists(
        "routePredictionReductionScatter",
        "reductionHash",
        reductionHash
      );
      // verify required parameter 'iou' is not null or undefined
      assertParamExists("routePredictionReductionScatter", "iou", iou);
      const localVarPath =
        `/api/projects_v2/{project_hash}/predictions/{prediction_hash}/analytics/{domain}/reductions/{reduction_hash}/summary`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(
            `{${"prediction_hash"}}`,
            encodeURIComponent(String(predictionHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)))
          .replace(
            `{${"reduction_hash"}}`,
            encodeURIComponent(String(reductionHash))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (iou !== undefined) {
        localVarQueryParameter["iou"] = iou;
      }

      if (buckets !== undefined) {
        localVarQueryParameter["buckets"] = buckets;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Prediction Scatter
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {string} xMetric
     * @param {string} yMetric
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionScatter: async (
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      xMetric: string,
      yMetric: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routePredictionScatter", "projectHash", projectHash);
      // verify required parameter 'predictionHash' is not null or undefined
      assertParamExists(
        "routePredictionScatter",
        "predictionHash",
        predictionHash
      );
      // verify required parameter 'domain' is not null or undefined
      assertParamExists("routePredictionScatter", "domain", domain);
      // verify required parameter 'iou' is not null or undefined
      assertParamExists("routePredictionScatter", "iou", iou);
      // verify required parameter 'xMetric' is not null or undefined
      assertParamExists("routePredictionScatter", "xMetric", xMetric);
      // verify required parameter 'yMetric' is not null or undefined
      assertParamExists("routePredictionScatter", "yMetric", yMetric);
      const localVarPath =
        `/api/projects_v2/{project_hash}/predictions/{prediction_hash}/analytics/{domain}/scatter`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(
            `{${"prediction_hash"}}`,
            encodeURIComponent(String(predictionHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (iou !== undefined) {
        localVarQueryParameter["iou"] = iou;
      }

      if (xMetric !== undefined) {
        localVarQueryParameter["x_metric"] = xMetric;
      }

      if (yMetric !== undefined) {
        localVarQueryParameter["y_metric"] = yMetric;
      }

      if (buckets !== undefined) {
        localVarQueryParameter["buckets"] = buckets;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Prediction Search
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {boolean} desc
     * @param {string} [filters] Search Filters
     * @param {string} [orderBy]
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [text]
     * @param {File} [image]
     * @param {string} [item]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionSearch: async (
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      desc: boolean,
      filters?: string,
      orderBy?: string,
      offset?: number,
      limit?: number,
      text?: string,
      image?: File,
      item?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routePredictionSearch", "projectHash", projectHash);
      // verify required parameter 'predictionHash' is not null or undefined
      assertParamExists(
        "routePredictionSearch",
        "predictionHash",
        predictionHash
      );
      // verify required parameter 'domain' is not null or undefined
      assertParamExists("routePredictionSearch", "domain", domain);
      // verify required parameter 'iou' is not null or undefined
      assertParamExists("routePredictionSearch", "iou", iou);
      // verify required parameter 'desc' is not null or undefined
      assertParamExists("routePredictionSearch", "desc", desc);
      const localVarPath =
        `/api/projects_v2/{project_hash}/predictions/{prediction_hash}/analytics/{domain}/search`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(
            `{${"prediction_hash"}}`,
            encodeURIComponent(String(predictionHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)();

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      if (iou !== undefined) {
        localVarFormParams.append("iou", iou as any);
      }

      if (orderBy !== undefined) {
        localVarFormParams.append("order_by", orderBy as any);
      }

      if (desc !== undefined) {
        localVarFormParams.append("desc", desc as any);
      }

      if (offset !== undefined) {
        localVarFormParams.append("offset", offset as any);
      }

      if (limit !== undefined) {
        localVarFormParams.append("limit", limit as any);
      }

      if (text !== undefined) {
        localVarFormParams.append("text", text as any);
      }

      if (image !== undefined) {
        localVarFormParams.append("image", image as any);
      }

      if (item !== undefined) {
        localVarFormParams.append("item", item as any);
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Prediction Summary
     * @param {string} predictionHash
     * @param {string} projectHash
     * @param {number} iou
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionSummary: async (
      predictionHash: string,
      projectHash: string,
      iou: number,
      filters?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'predictionHash' is not null or undefined
      assertParamExists(
        "routePredictionSummary",
        "predictionHash",
        predictionHash
      );
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routePredictionSummary", "projectHash", projectHash);
      // verify required parameter 'iou' is not null or undefined
      assertParamExists("routePredictionSummary", "iou", iou);
      const localVarPath =
        `/api/projects_v2/{project_hash}/predictions/{prediction_hash}/summary`
          .replace(
            `{${"prediction_hash"}}`,
            encodeURIComponent(String(predictionHash))
          )
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (iou !== undefined) {
        localVarQueryParameter["iou"] = iou;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Project Action Tag Items
     * @param {string} projectHash
     * @param {string} tagName
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectActionTagItems: async (
      projectHash: string,
      tagName: string,
      requestBody: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routeProjectActionTagItems",
        "projectHash",
        projectHash
      );
      // verify required parameter 'tagName' is not null or undefined
      assertParamExists("routeProjectActionTagItems", "tagName", tagName);
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists(
        "routeProjectActionTagItems",
        "requestBody",
        requestBody
      );
      const localVarPath = `/api/projects_v2/{project_hash}/create/tag`.replace(
        `{${"project_hash"}}`,
        encodeURIComponent(String(projectHash))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (tagName !== undefined) {
        localVarQueryParameter["tag_name"] = tagName;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Project Analysis Distribution
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} group
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectAnalysisDistribution: async (
      projectHash: string,
      domain: AnalysisDomain,
      group: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routeProjectAnalysisDistribution",
        "projectHash",
        projectHash
      );
      // verify required parameter 'domain' is not null or undefined
      assertParamExists("routeProjectAnalysisDistribution", "domain", domain);
      // verify required parameter 'group' is not null or undefined
      assertParamExists("routeProjectAnalysisDistribution", "group", group);
      const localVarPath =
        `/api/projects_v2/{project_hash}/analysis/{domain}/distribution`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (group !== undefined) {
        localVarQueryParameter["group"] = group;
      }

      if (buckets !== undefined) {
        localVarQueryParameter["buckets"] = buckets;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Project Analysis Distribution
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} group
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectAnalysisDistribution_13: async (
      projectHash: string,
      domain: AnalysisDomain,
      group: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routeProjectAnalysisDistribution_13",
        "projectHash",
        projectHash
      );
      // verify required parameter 'domain' is not null or undefined
      assertParamExists(
        "routeProjectAnalysisDistribution_13",
        "domain",
        domain
      );
      // verify required parameter 'group' is not null or undefined
      assertParamExists("routeProjectAnalysisDistribution_13", "group", group);
      const localVarPath =
        `/api/projects_v2/{project_hash}/analysis/{domain}/distribution`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (group !== undefined) {
        localVarQueryParameter["group"] = group;
      }

      if (buckets !== undefined) {
        localVarQueryParameter["buckets"] = buckets;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Project Analysis Reduction Scatter
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} reductionHash
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectAnalysisReductionScatter: async (
      projectHash: string,
      domain: AnalysisDomain,
      reductionHash: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routeProjectAnalysisReductionScatter",
        "projectHash",
        projectHash
      );
      // verify required parameter 'domain' is not null or undefined
      assertParamExists(
        "routeProjectAnalysisReductionScatter",
        "domain",
        domain
      );
      // verify required parameter 'reductionHash' is not null or undefined
      assertParamExists(
        "routeProjectAnalysisReductionScatter",
        "reductionHash",
        reductionHash
      );
      const localVarPath =
        `/api/projects_v2/{project_hash}/analysis/{domain}/reductions/{reduction_hash}/summary`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)))
          .replace(
            `{${"reduction_hash"}}`,
            encodeURIComponent(String(reductionHash))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (buckets !== undefined) {
        localVarQueryParameter["buckets"] = buckets;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Project Analysis Reduction Scatter
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} reductionHash
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectAnalysisReductionScatter_14: async (
      projectHash: string,
      domain: AnalysisDomain,
      reductionHash: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routeProjectAnalysisReductionScatter_14",
        "projectHash",
        projectHash
      );
      // verify required parameter 'domain' is not null or undefined
      assertParamExists(
        "routeProjectAnalysisReductionScatter_14",
        "domain",
        domain
      );
      // verify required parameter 'reductionHash' is not null or undefined
      assertParamExists(
        "routeProjectAnalysisReductionScatter_14",
        "reductionHash",
        reductionHash
      );
      const localVarPath =
        `/api/projects_v2/{project_hash}/analysis/{domain}/reductions/{reduction_hash}/summary`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)))
          .replace(
            `{${"reduction_hash"}}`,
            encodeURIComponent(String(reductionHash))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (buckets !== undefined) {
        localVarQueryParameter["buckets"] = buckets;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Project Analysis Scatter
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} xMetric
     * @param {string} yMetric
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectAnalysisScatter: async (
      projectHash: string,
      domain: AnalysisDomain,
      xMetric: string,
      yMetric: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routeProjectAnalysisScatter",
        "projectHash",
        projectHash
      );
      // verify required parameter 'domain' is not null or undefined
      assertParamExists("routeProjectAnalysisScatter", "domain", domain);
      // verify required parameter 'xMetric' is not null or undefined
      assertParamExists("routeProjectAnalysisScatter", "xMetric", xMetric);
      // verify required parameter 'yMetric' is not null or undefined
      assertParamExists("routeProjectAnalysisScatter", "yMetric", yMetric);
      const localVarPath =
        `/api/projects_v2/{project_hash}/analysis/{domain}/scatter`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (xMetric !== undefined) {
        localVarQueryParameter["x_metric"] = xMetric;
      }

      if (yMetric !== undefined) {
        localVarQueryParameter["y_metric"] = yMetric;
      }

      if (buckets !== undefined) {
        localVarQueryParameter["buckets"] = buckets;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Project Analysis Scatter
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} xMetric
     * @param {string} yMetric
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectAnalysisScatter_15: async (
      projectHash: string,
      domain: AnalysisDomain,
      xMetric: string,
      yMetric: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routeProjectAnalysisScatter_15",
        "projectHash",
        projectHash
      );
      // verify required parameter 'domain' is not null or undefined
      assertParamExists("routeProjectAnalysisScatter_15", "domain", domain);
      // verify required parameter 'xMetric' is not null or undefined
      assertParamExists("routeProjectAnalysisScatter_15", "xMetric", xMetric);
      // verify required parameter 'yMetric' is not null or undefined
      assertParamExists("routeProjectAnalysisScatter_15", "yMetric", yMetric);
      const localVarPath =
        `/api/projects_v2/{project_hash}/analysis/{domain}/scatter`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (xMetric !== undefined) {
        localVarQueryParameter["x_metric"] = xMetric;
      }

      if (yMetric !== undefined) {
        localVarQueryParameter["y_metric"] = yMetric;
      }

      if (buckets !== undefined) {
        localVarQueryParameter["buckets"] = buckets;
      }

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Project Analysis Search
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {boolean} desc
     * @param {string} [filters] Search Filters
     * @param {string} [orderBy]
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectAnalysisSearch: async (
      projectHash: string,
      domain: AnalysisDomain,
      desc: boolean,
      filters?: string,
      orderBy?: string,
      offset?: number,
      limit?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routeProjectAnalysisSearch",
        "projectHash",
        projectHash
      );
      // verify required parameter 'domain' is not null or undefined
      assertParamExists("routeProjectAnalysisSearch", "domain", domain);
      // verify required parameter 'desc' is not null or undefined
      assertParamExists("routeProjectAnalysisSearch", "desc", desc);
      const localVarPath =
        `/api/projects_v2/{project_hash}/analysis/{domain}/search`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new URLSearchParams();

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      if (orderBy !== undefined) {
        localVarFormParams.set("order_by", orderBy as any);
      }

      if (desc !== undefined) {
        localVarFormParams.set("desc", desc as any);
      }

      if (offset !== undefined) {
        localVarFormParams.set("offset", offset as any);
      }

      if (limit !== undefined) {
        localVarFormParams.set("limit", limit as any);
      }

      localVarHeaderParameter["Content-Type"] =
        "application/x-www-form-urlencoded";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams.toString();

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Project Analysis Search
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {boolean} desc
     * @param {string} [filters] Search Filters
     * @param {string} [orderBy]
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectSearchApiProjectsV2ProjectHashAnalysisDomainSearchPost_15:
      async (
        projectHash: string,
        domain: AnalysisDomain,
        desc: boolean,
        filters?: string,
        orderBy?: string,
        offset?: number,
        limit?: number,
        options: AxiosRequestConfig = {}
      ): Promise<RequestArgs> => {
        // verify required parameter 'projectHash' is not null or undefined
        assertParamExists(
          "routeProjectSearchApiProjectsV2ProjectHashAnalysisDomainSearchPost_15",
          "projectHash",
          projectHash
        );
        // verify required parameter 'domain' is not null or undefined
        assertParamExists(
          "routeProjectSearchApiProjectsV2ProjectHashAnalysisDomainSearchPost_15",
          "domain",
          domain
        );
        // verify required parameter 'desc' is not null or undefined
        assertParamExists(
          "routeProjectSearchApiProjectsV2ProjectHashAnalysisDomainSearchPost_15",
          "desc",
          desc
        );
        const localVarPath =
          `/api/projects_v2/{project_hash}/analysis/{domain}/search`
            .replace(
              `{${"project_hash"}}`,
              encodeURIComponent(String(projectHash))
            )
            .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = {
          method: "POST",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;
        const localVarFormParams = new URLSearchParams();

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

        if (orderBy !== undefined) {
          localVarFormParams.set("order_by", orderBy as any);
        }

        if (desc !== undefined) {
          localVarFormParams.set("desc", desc as any);
        }

        if (offset !== undefined) {
          localVarFormParams.set("offset", offset as any);
        }

        if (limit !== undefined) {
          localVarFormParams.set("limit", limit as any);
        }

        localVarHeaderParameter["Content-Type"] =
          "application/x-www-form-urlencoded";

        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };
        localVarRequestOptions.data = localVarFormParams.toString();

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Project Analysis Summary
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectAnalysisSummary: async (
      projectHash: string,
      domain: AnalysisDomain,
      filters?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routeProjectAnalysisSummary",
        "projectHash",
        projectHash
      );
      // verify required parameter 'domain' is not null or undefined
      assertParamExists("routeProjectAnalysisSummary", "domain", domain);
      const localVarPath =
        `/api/projects_v2/{project_hash}/analysis/{domain}/summary`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Project Analysis Summary
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectAnalysisSummary_17: async (
      projectHash: string,
      domain: AnalysisDomain,
      filters?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routeProjectAnalysisSummary_17",
        "projectHash",
        projectHash
      );
      // verify required parameter 'domain' is not null or undefined
      assertParamExists("routeProjectAnalysisSummary_17", "domain", domain);
      const localVarPath =
        `/api/projects_v2/{project_hash}/analysis/{domain}/summary`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (filters !== undefined) {
        localVarQueryParameter["filters"] = filters;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Project Compare Metric Dissimilarity
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} compareProjectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectCompareMetricDissimilarity: async (
      projectHash: string,
      domain: AnalysisDomain,
      compareProjectHash: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routeProjectCompareMetricDissimilarity",
        "projectHash",
        projectHash
      );
      // verify required parameter 'domain' is not null or undefined
      assertParamExists(
        "routeProjectCompareMetricDissimilarity",
        "domain",
        domain
      );
      // verify required parameter 'compareProjectHash' is not null or undefined
      assertParamExists(
        "routeProjectCompareMetricDissimilarity",
        "compareProjectHash",
        compareProjectHash
      );
      const localVarPath =
        `/api/projects_v2/{project_hash}/analysis/{domain}/project_compare/metric_dissimilarity`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (compareProjectHash !== undefined) {
        localVarQueryParameter["compare_project_hash"] = compareProjectHash;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Project Compare Metric Dissimilarity
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} compareProjectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectCompareMetricDissimilarity_18: async (
      projectHash: string,
      domain: AnalysisDomain,
      compareProjectHash: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routeProjectCompareMetricDissimilarity_18",
        "projectHash",
        projectHash
      );
      // verify required parameter 'domain' is not null or undefined
      assertParamExists(
        "routeProjectCompareMetricDissimilarity_18",
        "domain",
        domain
      );
      // verify required parameter 'compareProjectHash' is not null or undefined
      assertParamExists(
        "routeProjectCompareMetricDissimilarity_18",
        "compareProjectHash",
        compareProjectHash
      );
      const localVarPath =
        `/api/projects_v2/{project_hash}/analysis/{domain}/project_compare/metric_dissimilarity`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (compareProjectHash !== undefined) {
        localVarQueryParameter["compare_project_hash"] = compareProjectHash;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Project Data Item
     * @param {string} projectHash
     * @param {string} dataItem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectDataItem: async (
      projectHash: string,
      dataItem: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeProjectDataItem", "projectHash", projectHash);
      // verify required parameter 'dataItem' is not null or undefined
      assertParamExists("routeProjectDataItem", "dataItem", dataItem);
      const localVarPath = `/api/projects_v2/{project_hash}/item/{data_item}/`
        .replace(`{${"project_hash"}}`, encodeURIComponent(String(projectHash)))
        .replace(`{${"data_item"}}`, encodeURIComponent(String(dataItem)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Project List Collaborators
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectListCollaborators: async (
      projectHash: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routeProjectListCollaborators",
        "projectHash",
        projectHash
      );
      const localVarPath =
        `/api/projects_v2/{project_hash}/collaborators`.replace(
          `{${"project_hash"}}`,
          encodeURIComponent(String(projectHash))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Project List Predictions
     * @param {string} projectHash
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {RouteProjectListPredictionsOrderByEnum} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectListPredictions: async (
      projectHash: string,
      offset?: number,
      limit?: number,
      orderBy?: RouteProjectListPredictionsOrderByEnum,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routeProjectListPredictions",
        "projectHash",
        projectHash
      );
      const localVarPath =
        `/api/projects_v2/{project_hash}/predictions`.replace(
          `{${"project_hash"}}`,
          encodeURIComponent(String(projectHash))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (orderBy !== undefined) {
        localVarQueryParameter["order_by"] = orderBy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Project List Reductions
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectListReductions: async (
      projectHash: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists(
        "routeProjectListReductions",
        "projectHash",
        projectHash
      );
      const localVarPath = `/api/projects_v2/{project_hash}/reductions`.replace(
        `{${"project_hash"}}`,
        encodeURIComponent(String(projectHash))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Project Metadata
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectMetadata: async (
      projectHash: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeProjectMetadata", "projectHash", projectHash);
      const localVarPath = `/api/projects_v2/{project_hash}/metadata`.replace(
        `{${"project_hash"}}`,
        encodeURIComponent(String(projectHash))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Project Raw File
     * @param {string} projectHash
     * @param {string} duHash
     * @param {number} frame
     * @param {string} [ifNoneMatch]
     * @param {string} [ifModifiedSince]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectRawFile: async (
      projectHash: string,
      duHash: string,
      frame: number,
      ifNoneMatch?: string,
      ifModifiedSince?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeProjectRawFile", "projectHash", projectHash);
      // verify required parameter 'duHash' is not null or undefined
      assertParamExists("routeProjectRawFile", "duHash", duHash);
      // verify required parameter 'frame' is not null or undefined
      assertParamExists("routeProjectRawFile", "frame", frame);
      const localVarPath =
        `/api/projects_v2/{project_hash}/files/{du_hash}/{frame}`
          .replace(
            `{${"project_hash"}}`,
            encodeURIComponent(String(projectHash))
          )
          .replace(`{${"du_hash"}}`, encodeURIComponent(String(duHash)))
          .replace(`{${"frame"}}`, encodeURIComponent(String(frame)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      if (ifNoneMatch != null) {
        localVarHeaderParameter["if-none-match"] = String(ifNoneMatch);
      }

      if (ifModifiedSince != null) {
        localVarHeaderParameter["if-modified-since"] = String(ifModifiedSince);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Project Summary
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectSummary: async (
      projectHash: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeProjectSummary", "projectHash", projectHash);
      const localVarPath = `/api/projects_v2/{project_hash}/summary`.replace(
        `{${"project_hash"}}`,
        encodeURIComponent(String(projectHash))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Update Tag
     * @param {string} projectHash
     * @param {string} tagHash
     * @param {ProjectTagRequest} projectTagRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeUpdateTag: async (
      projectHash: string,
      tagHash: string,
      projectTagRequest: ProjectTagRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeUpdateTag", "projectHash", projectHash);
      // verify required parameter 'tagHash' is not null or undefined
      assertParamExists("routeUpdateTag", "tagHash", tagHash);
      // verify required parameter 'projectTagRequest' is not null or undefined
      assertParamExists(
        "routeUpdateTag",
        "projectTagRequest",
        projectTagRequest
      );
      const localVarPath = `/api/projects_v2/{project_hash}/tags/{tag_hash}`
        .replace(`{${"project_hash"}}`, encodeURIComponent(String(projectHash)))
        .replace(`{${"tag_hash"}}`, encodeURIComponent(String(tagHash)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        projectTagRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Route Update Tag
     * @param {string} projectHash
     * @param {string} tagHash
     * @param {ProjectTagRequest} projectTagRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeUpdateTag_19: async (
      projectHash: string,
      tagHash: string,
      projectTagRequest: ProjectTagRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectHash' is not null or undefined
      assertParamExists("routeUpdateTag_19", "projectHash", projectHash);
      // verify required parameter 'tagHash' is not null or undefined
      assertParamExists("routeUpdateTag_19", "tagHash", tagHash);
      // verify required parameter 'projectTagRequest' is not null or undefined
      assertParamExists(
        "routeUpdateTag_19",
        "projectTagRequest",
        projectTagRequest
      );
      const localVarPath = `/api/projects_v2/{project_hash}/tags/{tag_hash}`
        .replace(`{${"project_hash"}}`, encodeURIComponent(String(projectHash)))
        .replace(`{${"tag_hash"}}`, encodeURIComponent(String(tagHash)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2PasswordBearer required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2PasswordBearer",
        [],
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        projectTagRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ProjectApi - functional programming interface
 * @export
 */
export const ProjectApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ProjectApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Route Action Create Project Subset
     * @param {string} projectHash
     * @param {CreateProjectSubsetPostAction} createProjectSubsetPostAction
     * @param {boolean} [remoteOnly]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeActionCreateProjectSubset(
      projectHash: string,
      createProjectSubsetPostAction: CreateProjectSubsetPostAction,
      remoteOnly?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeActionCreateProjectSubset(
          projectHash,
          createProjectSubsetPostAction,
          remoteOnly,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Action Create Project Subset
     * @param {string} projectHash
     * @param {CreateProjectSubsetPostAction} createProjectSubsetPostAction
     * @param {boolean} [remoteOnly]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeActionCreateProjectSubset_1(
      projectHash: string,
      createProjectSubsetPostAction: CreateProjectSubsetPostAction,
      remoteOnly?: boolean,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeActionCreateProjectSubset_1(
          projectHash,
          createProjectSubsetPostAction,
          remoteOnly,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Action Upload Project To Encord
     * @param {string} projectHash
     * @param {UploadProjectToEncordPostAction} uploadProjectToEncordPostAction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeActionUploadProjectToEncord(
      projectHash: string,
      uploadProjectToEncordPostAction: UploadProjectToEncordPostAction,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeActionUploadProjectToEncord(
          projectHash,
          uploadProjectToEncordPostAction,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Action Upload Project To Encord
     * @param {string} projectHash
     * @param {UploadProjectToEncordPostAction} uploadProjectToEncordPostAction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeActionUploadProjectToEncord_2(
      projectHash: string,
      uploadProjectToEncordPostAction: UploadProjectToEncordPostAction,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeActionUploadProjectToEncord_2(
          projectHash,
          uploadProjectToEncordPostAction,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Create Tags
     * @param {string} projectHash
     * @param {Array<ProjectTagRequest>} projectTagRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeCreateTags(
      projectHash: string,
      projectTagRequest: Array<ProjectTagRequest>,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string | undefined }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.routeCreateTags(
        projectHash,
        projectTagRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Create Tags
     * @param {string} projectHash
     * @param {Array<ProjectTagRequest>} projectTagRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeCreateTags_3(
      projectHash: string,
      projectTagRequest: Array<ProjectTagRequest>,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: string | undefined }>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeCreateTags_3(
          projectHash,
          projectTagRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Delete Tag
     * @param {string} projectHash
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeDeleteTag(
      projectHash: string,
      requestBody: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.routeDeleteTag(
        projectHash,
        requestBody,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Delete Tag
     * @param {string} projectHash
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeDeleteTag_4(
      projectHash: string,
      requestBody: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeDeleteTag_4(
          projectHash,
          requestBody,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Filter All Tags
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {SearchFilters} searchFilters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeFilterAllTags(
      projectHash: string,
      domain: AnalysisDomain,
      searchFilters: SearchFilters,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllTagsResult>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeFilterAllTags(
          projectHash,
          domain,
          searchFilters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Filter All Tags
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {SearchFilters} searchFilters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeFilterAllTags_5(
      projectHash: string,
      domain: AnalysisDomain,
      searchFilters: SearchFilters,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllTagsResult>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeFilterAllTags_5(
          projectHash,
          domain,
          searchFilters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Filter Tag All
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {BodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost} bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeFilterTagAll(
      projectHash: string,
      domain: AnalysisDomain,
      bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost: BodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeFilterTagAll(
          projectHash,
          domain,
          bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Filter Tag All
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {BodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost} bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeFilterTagAll_6(
      projectHash: string,
      domain: AnalysisDomain,
      bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost: BodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeFilterTagAll_6(
          projectHash,
          domain,
          bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Filter Untag All
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {BodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost} bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeFilterUntagAll(
      projectHash: string,
      domain: AnalysisDomain,
      bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost: BodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeFilterUntagAll(
          projectHash,
          domain,
          bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Filter Untag All
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {BodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost} bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeFilterUntagAll_7(
      projectHash: string,
      domain: AnalysisDomain,
      bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost: BodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeFilterUntagAll_7(
          projectHash,
          domain,
          bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Items All Tags
     * @param {string} projectHash
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeItemsAllTags(
      projectHash: string,
      requestBody: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllTagsResult>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeItemsAllTags(
          projectHash,
          requestBody,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Items All Tags
     * @param {string} projectHash
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeItemsAllTags_8(
      projectHash: string,
      requestBody: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllTagsResult>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeItemsAllTags_8(
          projectHash,
          requestBody,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Items Tag All
     * @param {string} projectHash
     * @param {BodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost} bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeItemsTagAll(
      projectHash: string,
      bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost: BodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeItemsTagAll(
          projectHash,
          bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Items Tag All
     * @param {string} projectHash
     * @param {BodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost} bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeItemsTagAll_9(
      projectHash: string,
      bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost: BodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeItemsTagAll_9(
          projectHash,
          bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Items Untag All
     * @param {string} projectHash
     * @param {BodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost} bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeItemsUntagAll(
      projectHash: string,
      bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost: BodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeItemsUntagAll(
          projectHash,
          bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Items Untag All
     * @param {string} projectHash
     * @param {BodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost} bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeItemsUntagAll_10(
      projectHash: string,
      bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost: BodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeItemsUntagAll_10(
          projectHash,
          bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route List Projects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeListProjects(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ProjectSearchResult>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeListProjects(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route List Tags
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeListTags(
      projectHash: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ProjectTagEntry>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.routeListTags(
        projectHash,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route List Tags Meta
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeListTagsMeta(
      projectHash: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ProjectTagEntryMeta>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeListTagsMeta(projectHash, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route List Tags Meta
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeListTagsMeta_11(
      projectHash: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ProjectTagEntryMeta>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeListTagsMeta_11(
          projectHash,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route List Tags
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeListTags_12(
      projectHash: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ProjectTagEntry>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeListTags_12(projectHash, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Prediction Data Item
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {string} dataItem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routePredictionDataItem(
      projectHash: string,
      predictionHash: string,
      dataItem: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PredictionItem>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routePredictionDataItem(
          projectHash,
          predictionHash,
          dataItem,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Prediction Distribution
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {string} group
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routePredictionDistribution(
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      group: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<QueryDistribution>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routePredictionDistribution(
          projectHash,
          predictionHash,
          domain,
          iou,
          group,
          buckets,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Prediction Metric Performance
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {number} iou
     * @param {string} metricName
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routePredictionMetricPerformance(
      projectHash: string,
      predictionHash: string,
      iou: number,
      metricName: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<QueryMetricPerformance>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routePredictionMetricPerformance(
          projectHash,
          predictionHash,
          iou,
          metricName,
          buckets,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Prediction Reduction Scatter
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {string} reductionHash
     * @param {number} iou
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routePredictionReductionScatter(
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      reductionHash: string,
      iou: number,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PredictionQuery2DEmbedding>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routePredictionReductionScatter(
          projectHash,
          predictionHash,
          domain,
          reductionHash,
          iou,
          buckets,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Prediction Scatter
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {string} xMetric
     * @param {string} yMetric
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routePredictionScatter(
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      xMetric: string,
      yMetric: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryScatter>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routePredictionScatter(
          projectHash,
          predictionHash,
          domain,
          iou,
          xMetric,
          yMetric,
          buckets,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Prediction Search
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {boolean} desc
     * @param {string} [filters] Search Filters
     * @param {string} [orderBy]
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [text]
     * @param {File} [image]
     * @param {string} [item]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routePredictionSearch(
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      desc: boolean,
      filters?: string,
      orderBy?: string,
      offset?: number,
      limit?: number,
      text?: string,
      image?: File,
      item?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalysisSearch>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routePredictionSearch(
          projectHash,
          predictionHash,
          domain,
          iou,
          desc,
          filters,
          orderBy,
          offset,
          limit,
          text,
          image,
          item,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Prediction Summary
     * @param {string} predictionHash
     * @param {string} projectHash
     * @param {number} iou
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routePredictionSummary(
      predictionHash: string,
      projectHash: string,
      iou: number,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PredictionSummaryResult>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routePredictionSummary(
          predictionHash,
          projectHash,
          iou,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Action Tag Items
     * @param {string} projectHash
     * @param {string} tagName
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectActionTagItems(
      projectHash: string,
      tagName: string,
      requestBody: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectActionTagItems(
          projectHash,
          tagName,
          requestBody,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Analysis Distribution
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} group
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectAnalysisDistribution(
      projectHash: string,
      domain: AnalysisDomain,
      group: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<QueryDistribution>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectAnalysisDistribution(
          projectHash,
          domain,
          group,
          buckets,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Analysis Distribution
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} group
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectAnalysisDistribution_13(
      projectHash: string,
      domain: AnalysisDomain,
      group: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<QueryDistribution>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectAnalysisDistribution_13(
          projectHash,
          domain,
          group,
          buckets,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Analysis Reduction Scatter
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} reductionHash
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectAnalysisReductionScatter(
      projectHash: string,
      domain: AnalysisDomain,
      reductionHash: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Query2DEmbedding>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectAnalysisReductionScatter(
          projectHash,
          domain,
          reductionHash,
          buckets,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Analysis Reduction Scatter
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} reductionHash
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectAnalysisReductionScatter_14(
      projectHash: string,
      domain: AnalysisDomain,
      reductionHash: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Query2DEmbedding>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectAnalysisReductionScatter_14(
          projectHash,
          domain,
          reductionHash,
          buckets,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Analysis Scatter
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} xMetric
     * @param {string} yMetric
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectAnalysisScatter(
      projectHash: string,
      domain: AnalysisDomain,
      xMetric: string,
      yMetric: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryScatter>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectAnalysisScatter(
          projectHash,
          domain,
          xMetric,
          yMetric,
          buckets,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Analysis Scatter
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} xMetric
     * @param {string} yMetric
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectAnalysisScatter_15(
      projectHash: string,
      domain: AnalysisDomain,
      xMetric: string,
      yMetric: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryScatter>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectAnalysisScatter_15(
          projectHash,
          domain,
          xMetric,
          yMetric,
          buckets,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Analysis Search
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {boolean} desc
     * @param {string} [filters] Search Filters
     * @param {string} [orderBy]
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [text]
     * @param {File} [image]
     * @param {string} [item]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectAnalysisSearch(
      projectHash: string,
      domain: AnalysisDomain,
      desc: boolean,
      filters?: string,
      orderBy?: string,
      offset?: number,
      limit?: number,
      text?: string,
      image?: File,
      item?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalysisSearch>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectAnalysisSearch(
          projectHash,
          domain,
          desc,
          filters,
          orderBy,
          offset,
          limit,
          text,
          image,
          item,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Analysis Search
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {boolean} desc
     * @param {string} [filters] Search Filters
     * @param {string} [orderBy]
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [text]
     * @param {File} [image]
     * @param {string} [item]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectAnalysisSearch_16(
      projectHash: string,
      domain: AnalysisDomain,
      desc: boolean,
      filters?: string,
      orderBy?: string,
      offset?: number,
      limit?: number,
      text?: string,
      image?: File,
      item?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalysisSearch>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectAnalysisSearch_16(
          projectHash,
          domain,
          desc,
          filters,
          orderBy,
          offset,
          limit,
          text,
          image,
          item,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Analysis Summary
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectAnalysisSummary(
      projectHash: string,
      domain: AnalysisDomain,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuerySummary>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectAnalysisSummary(
          projectHash,
          domain,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Analysis Summary
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectAnalysisSummary_17(
      projectHash: string,
      domain: AnalysisDomain,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuerySummary>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectAnalysisSummary_17(
          projectHash,
          domain,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Compare Metric Dissimilarity
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} compareProjectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectCompareMetricDissimilarity(
      projectHash: string,
      domain: AnalysisDomain,
      compareProjectHash: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MetricDissimilarityResult>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectCompareMetricDissimilarity(
          projectHash,
          domain,
          compareProjectHash,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Compare Metric Dissimilarity
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} compareProjectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectCompareMetricDissimilarity_18(
      projectHash: string,
      domain: AnalysisDomain,
      compareProjectHash: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MetricDissimilarityResult>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectCompareMetricDissimilarity_18(
          projectHash,
          domain,
          compareProjectHash,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Data Item
     * @param {string} projectHash
     * @param {string} dataItem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectDataItem(
      projectHash: string,
      dataItem: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectItem>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectDataItem(
          projectHash,
          dataItem,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project List Collaborators
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectListCollaborators(
      projectHash: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ProjectCollaboratorEntry>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectListCollaborators(
          projectHash,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project List Predictions
     * @param {string} projectHash
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {RouteProjectListPredictionsOrderByEnum} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectListPredictions(
      projectHash: string,
      offset?: number,
      limit?: number,
      orderBy?: RouteProjectListPredictionsOrderByEnum,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListProjectPredictionResult>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectListPredictions(
          projectHash,
          offset,
          limit,
          orderBy,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project List Reductions
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectListReductions(
      projectHash: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ProjectList2DEmbeddingReductionResult>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectListReductions(
          projectHash,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Metadata
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectMetadata(
      projectHash: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ProjectMetadata>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectMetadata(
          projectHash,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Raw File
     * @param {string} projectHash
     * @param {string} duHash
     * @param {number} frame
     * @param {string} [ifNoneMatch]
     * @param {string} [ifModifiedSince]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectRawFile(
      projectHash: string,
      duHash: string,
      frame: number,
      ifNoneMatch?: string,
      ifModifiedSince?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectRawFile(
          projectHash,
          duHash,
          frame,
          ifNoneMatch,
          ifModifiedSince,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Reduction Scatter
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} reductionHash
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectReductionScatterApiProjectsV2ProjectHashAnalysisDomainReductionsReductionHashSummaryGet(
      projectHash: string,
      domain: AnalysisDomain,
      reductionHash: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Query2DEmbedding>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectReductionScatterApiProjectsV2ProjectHashAnalysisDomainReductionsReductionHashSummaryGet(
          projectHash,
          domain,
          reductionHash,
          buckets,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Reduction Scatter
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} reductionHash
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectReductionScatterApiProjectsV2ProjectHashAnalysisDomainReductionsReductionHashSummaryGet_13(
      projectHash: string,
      domain: AnalysisDomain,
      reductionHash: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Query2DEmbedding>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectReductionScatterApiProjectsV2ProjectHashAnalysisDomainReductionsReductionHashSummaryGet_13(
          projectHash,
          domain,
          reductionHash,
          buckets,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Scatter
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} xMetric
     * @param {string} yMetric
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectScatterApiProjectsV2ProjectHashAnalysisDomainScatterGet(
      projectHash: string,
      domain: AnalysisDomain,
      xMetric: string,
      yMetric: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryScatter>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectScatterApiProjectsV2ProjectHashAnalysisDomainScatterGet(
          projectHash,
          domain,
          xMetric,
          yMetric,
          buckets,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Scatter
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} xMetric
     * @param {string} yMetric
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectScatterApiProjectsV2ProjectHashAnalysisDomainScatterGet_14(
      projectHash: string,
      domain: AnalysisDomain,
      xMetric: string,
      yMetric: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryScatter>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectScatterApiProjectsV2ProjectHashAnalysisDomainScatterGet_14(
          projectHash,
          domain,
          xMetric,
          yMetric,
          buckets,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Search
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {boolean} desc
     * @param {string} [filters] Search Filters
     * @param {string} [orderBy]
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectSearchApiProjectsV2ProjectHashAnalysisDomainSearchPost(
      projectHash: string,
      domain: AnalysisDomain,
      desc: boolean,
      filters?: string,
      orderBy?: string,
      offset?: number,
      limit?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalysisSearch>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectSearchApiProjectsV2ProjectHashAnalysisDomainSearchPost(
          projectHash,
          domain,
          desc,
          filters,
          orderBy,
          offset,
          limit,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Search
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {boolean} desc
     * @param {string} [filters] Search Filters
     * @param {string} [orderBy]
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectSearchApiProjectsV2ProjectHashAnalysisDomainSearchPost_15(
      projectHash: string,
      domain: AnalysisDomain,
      desc: boolean,
      filters?: string,
      orderBy?: string,
      offset?: number,
      limit?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalysisSearch>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectSearchApiProjectsV2ProjectHashAnalysisDomainSearchPost_15(
          projectHash,
          domain,
          desc,
          filters,
          orderBy,
          offset,
          limit,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Summary
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectSummaryApiProjectsV2ProjectHashAnalysisDomainSummaryGet(
      projectHash: string,
      domain: AnalysisDomain,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuerySummary>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectSummaryApiProjectsV2ProjectHashAnalysisDomainSummaryGet(
          projectHash,
          domain,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Summary
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectSummaryApiProjectsV2ProjectHashAnalysisDomainSummaryGet_16(
      projectHash: string,
      domain: AnalysisDomain,
      filters?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuerySummary>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectSummaryApiProjectsV2ProjectHashAnalysisDomainSummaryGet_16(
          projectHash,
          domain,
          filters,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Project Summary
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeProjectSummary(
      projectHash: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectSummary>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeProjectSummary(
          projectHash,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Update Tag
     * @param {string} projectHash
     * @param {string} tagHash
     * @param {ProjectTagRequest} projectTagRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeUpdateTag(
      projectHash: string,
      tagHash: string,
      projectTagRequest: ProjectTagRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.routeUpdateTag(
        projectHash,
        tagHash,
        projectTagRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Route Update Tag
     * @param {string} projectHash
     * @param {string} tagHash
     * @param {ProjectTagRequest} projectTagRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async routeUpdateTag_19(
      projectHash: string,
      tagHash: string,
      projectTagRequest: ProjectTagRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.routeUpdateTag_19(
          projectHash,
          tagHash,
          projectTagRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ProjectApi - factory interface
 * @export
 */
export const ProjectApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ProjectApiFp(configuration);
  return {
    /**
     *
     * @summary Route Action Create Project Subset
     * @param {string} projectHash
     * @param {CreateProjectSubsetPostAction} createProjectSubsetPostAction
     * @param {boolean} [remoteOnly]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeActionCreateProjectSubset(
      projectHash: string,
      createProjectSubsetPostAction: CreateProjectSubsetPostAction,
      remoteOnly?: boolean,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .routeActionCreateProjectSubset(
          projectHash,
          createProjectSubsetPostAction,
          remoteOnly,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Action Create Project Subset
     * @param {string} projectHash
     * @param {CreateProjectSubsetPostAction} createProjectSubsetPostAction
     * @param {boolean} [remoteOnly]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeActionCreateProjectSubset_1(
      projectHash: string,
      createProjectSubsetPostAction: CreateProjectSubsetPostAction,
      remoteOnly?: boolean,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .routeActionCreateProjectSubset_1(
          projectHash,
          createProjectSubsetPostAction,
          remoteOnly,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Action Upload Project To Encord
     * @param {string} projectHash
     * @param {UploadProjectToEncordPostAction} uploadProjectToEncordPostAction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeActionUploadProjectToEncord(
      projectHash: string,
      uploadProjectToEncordPostAction: UploadProjectToEncordPostAction,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .routeActionUploadProjectToEncord(
          projectHash,
          uploadProjectToEncordPostAction,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Action Upload Project To Encord
     * @param {string} projectHash
     * @param {UploadProjectToEncordPostAction} uploadProjectToEncordPostAction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeActionUploadProjectToEncord_2(
      projectHash: string,
      uploadProjectToEncordPostAction: UploadProjectToEncordPostAction,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .routeActionUploadProjectToEncord_2(
          projectHash,
          uploadProjectToEncordPostAction,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Create Tags
     * @param {string} projectHash
     * @param {Array<ProjectTagRequest>} projectTagRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeCreateTags(
      projectHash: string,
      projectTagRequest: Array<ProjectTagRequest>,
      options?: any
    ): AxiosPromise<{ [key: string]: string | undefined }> {
      return localVarFp
        .routeCreateTags(projectHash, projectTagRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Create Tags
     * @param {string} projectHash
     * @param {Array<ProjectTagRequest>} projectTagRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeCreateTags_3(
      projectHash: string,
      projectTagRequest: Array<ProjectTagRequest>,
      options?: any
    ): AxiosPromise<{ [key: string]: string | undefined }> {
      return localVarFp
        .routeCreateTags_3(projectHash, projectTagRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Delete Tag
     * @param {string} projectHash
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeDeleteTag(
      projectHash: string,
      requestBody: Array<string>,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .routeDeleteTag(projectHash, requestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Delete Tag
     * @param {string} projectHash
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeDeleteTag_4(
      projectHash: string,
      requestBody: Array<string>,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .routeDeleteTag_4(projectHash, requestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Filter All Tags
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {SearchFilters} searchFilters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeFilterAllTags(
      projectHash: string,
      domain: AnalysisDomain,
      searchFilters: SearchFilters,
      options?: any
    ): AxiosPromise<AllTagsResult> {
      return localVarFp
        .routeFilterAllTags(projectHash, domain, searchFilters, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Filter All Tags
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {SearchFilters} searchFilters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeFilterAllTags_5(
      projectHash: string,
      domain: AnalysisDomain,
      searchFilters: SearchFilters,
      options?: any
    ): AxiosPromise<AllTagsResult> {
      return localVarFp
        .routeFilterAllTags_5(projectHash, domain, searchFilters, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Filter Tag All
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {BodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost} bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeFilterTagAll(
      projectHash: string,
      domain: AnalysisDomain,
      bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost: BodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .routeFilterTagAll(
          projectHash,
          domain,
          bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Filter Tag All
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {BodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost} bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeFilterTagAll_6(
      projectHash: string,
      domain: AnalysisDomain,
      bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost: BodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .routeFilterTagAll_6(
          projectHash,
          domain,
          bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Filter Untag All
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {BodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost} bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeFilterUntagAll(
      projectHash: string,
      domain: AnalysisDomain,
      bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost: BodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .routeFilterUntagAll(
          projectHash,
          domain,
          bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Filter Untag All
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {BodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost} bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeFilterUntagAll_7(
      projectHash: string,
      domain: AnalysisDomain,
      bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost: BodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .routeFilterUntagAll_7(
          projectHash,
          domain,
          bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Items All Tags
     * @param {string} projectHash
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeItemsAllTags(
      projectHash: string,
      requestBody: Array<string>,
      options?: any
    ): AxiosPromise<AllTagsResult> {
      return localVarFp
        .routeItemsAllTags(projectHash, requestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Items All Tags
     * @param {string} projectHash
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeItemsAllTags_8(
      projectHash: string,
      requestBody: Array<string>,
      options?: any
    ): AxiosPromise<AllTagsResult> {
      return localVarFp
        .routeItemsAllTags_8(projectHash, requestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Items Tag All
     * @param {string} projectHash
     * @param {BodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost} bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeItemsTagAll(
      projectHash: string,
      bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost: BodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .routeItemsTagAll(
          projectHash,
          bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Items Tag All
     * @param {string} projectHash
     * @param {BodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost} bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeItemsTagAll_9(
      projectHash: string,
      bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost: BodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .routeItemsTagAll_9(
          projectHash,
          bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Items Untag All
     * @param {string} projectHash
     * @param {BodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost} bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeItemsUntagAll(
      projectHash: string,
      bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost: BodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .routeItemsUntagAll(
          projectHash,
          bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Items Untag All
     * @param {string} projectHash
     * @param {BodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost} bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeItemsUntagAll_10(
      projectHash: string,
      bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost: BodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .routeItemsUntagAll_10(
          projectHash,
          bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route List Projects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeListProjects(options?: any): AxiosPromise<ProjectSearchResult> {
      return localVarFp
        .routeListProjects(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route List Tags
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeListTags(
      projectHash: string,
      options?: any
    ): AxiosPromise<Array<ProjectTagEntry>> {
      return localVarFp
        .routeListTags(projectHash, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route List Tags Meta
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeListTagsMeta(
      projectHash: string,
      options?: any
    ): AxiosPromise<Array<ProjectTagEntryMeta>> {
      return localVarFp
        .routeListTagsMeta(projectHash, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route List Tags Meta
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeListTagsMeta_11(
      projectHash: string,
      options?: any
    ): AxiosPromise<Array<ProjectTagEntryMeta>> {
      return localVarFp
        .routeListTagsMeta_11(projectHash, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route List Tags
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeListTags_12(
      projectHash: string,
      options?: any
    ): AxiosPromise<Array<ProjectTagEntry>> {
      return localVarFp
        .routeListTags_12(projectHash, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Prediction Data Item
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {string} dataItem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionDataItem(
      projectHash: string,
      predictionHash: string,
      dataItem: string,
      options?: any
    ): AxiosPromise<PredictionItem> {
      return localVarFp
        .routePredictionDataItem(projectHash, predictionHash, dataItem, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Prediction Distribution
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {string} group
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionDistribution(
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      group: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: any
    ): AxiosPromise<QueryDistribution> {
      return localVarFp
        .routePredictionDistribution(
          projectHash,
          predictionHash,
          domain,
          iou,
          group,
          buckets,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Prediction Metric Performance
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {number} iou
     * @param {string} metricName
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionMetricPerformance(
      projectHash: string,
      predictionHash: string,
      iou: number,
      metricName: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: any
    ): AxiosPromise<QueryMetricPerformance> {
      return localVarFp
        .routePredictionMetricPerformance(
          projectHash,
          predictionHash,
          iou,
          metricName,
          buckets,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Prediction Reduction Scatter
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {string} reductionHash
     * @param {number} iou
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionReductionScatter(
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      reductionHash: string,
      iou: number,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: any
    ): AxiosPromise<PredictionQuery2DEmbedding> {
      return localVarFp
        .routePredictionReductionScatter(
          projectHash,
          predictionHash,
          domain,
          reductionHash,
          iou,
          buckets,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Prediction Scatter
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {string} xMetric
     * @param {string} yMetric
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionScatter(
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      xMetric: string,
      yMetric: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: any
    ): AxiosPromise<QueryScatter> {
      return localVarFp
        .routePredictionScatter(
          projectHash,
          predictionHash,
          domain,
          iou,
          xMetric,
          yMetric,
          buckets,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Prediction Search
     * @param {string} projectHash
     * @param {string} predictionHash
     * @param {PredictionDomain} domain
     * @param {number} iou
     * @param {boolean} desc
     * @param {string} [filters] Search Filters
     * @param {string} [orderBy]
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [text]
     * @param {File} [image]
     * @param {string} [item]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionSearch(
      projectHash: string,
      predictionHash: string,
      domain: PredictionDomain,
      iou: number,
      desc: boolean,
      filters?: string,
      orderBy?: string,
      offset?: number,
      limit?: number,
      text?: string,
      image?: File,
      item?: string,
      options?: any
    ): AxiosPromise<AnalysisSearch> {
      return localVarFp
        .routePredictionSearch(
          projectHash,
          predictionHash,
          domain,
          iou,
          desc,
          filters,
          orderBy,
          offset,
          limit,
          text,
          image,
          item,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Prediction Summary
     * @param {string} predictionHash
     * @param {string} projectHash
     * @param {number} iou
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routePredictionSummary(
      predictionHash: string,
      projectHash: string,
      iou: number,
      filters?: string,
      options?: any
    ): AxiosPromise<PredictionSummaryResult> {
      return localVarFp
        .routePredictionSummary(
          predictionHash,
          projectHash,
          iou,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Action Tag Items
     * @param {string} projectHash
     * @param {string} tagName
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectActionTagItems(
      projectHash: string,
      tagName: string,
      requestBody: Array<string>,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .routeProjectActionTagItems(projectHash, tagName, requestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Analysis Distribution
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} group
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectAnalysisDistribution(
      projectHash: string,
      domain: AnalysisDomain,
      group: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: any
    ): AxiosPromise<QueryDistribution> {
      return localVarFp
        .routeProjectAnalysisDistribution(
          projectHash,
          domain,
          group,
          buckets,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Analysis Distribution
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} group
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectAnalysisDistribution_13(
      projectHash: string,
      domain: AnalysisDomain,
      group: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: any
    ): AxiosPromise<QueryDistribution> {
      return localVarFp
        .routeProjectAnalysisDistribution_13(
          projectHash,
          domain,
          group,
          buckets,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Analysis Reduction Scatter
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} reductionHash
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectAnalysisReductionScatter(
      projectHash: string,
      domain: AnalysisDomain,
      reductionHash: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: any
    ): AxiosPromise<Query2DEmbedding> {
      return localVarFp
        .routeProjectAnalysisReductionScatter(
          projectHash,
          domain,
          reductionHash,
          buckets,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Analysis Reduction Scatter
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} reductionHash
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectAnalysisReductionScatter_14(
      projectHash: string,
      domain: AnalysisDomain,
      reductionHash: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: any
    ): AxiosPromise<Query2DEmbedding> {
      return localVarFp
        .routeProjectAnalysisReductionScatter_14(
          projectHash,
          domain,
          reductionHash,
          buckets,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Analysis Scatter
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} xMetric
     * @param {string} yMetric
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectAnalysisScatter(
      projectHash: string,
      domain: AnalysisDomain,
      xMetric: string,
      yMetric: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: any
    ): AxiosPromise<QueryScatter> {
      return localVarFp
        .routeProjectAnalysisScatter(
          projectHash,
          domain,
          xMetric,
          yMetric,
          buckets,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Analysis Scatter
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} xMetric
     * @param {string} yMetric
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectAnalysisScatter_15(
      projectHash: string,
      domain: AnalysisDomain,
      xMetric: string,
      yMetric: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: any
    ): AxiosPromise<QueryScatter> {
      return localVarFp
        .routeProjectAnalysisScatter_15(
          projectHash,
          domain,
          xMetric,
          yMetric,
          buckets,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Analysis Search
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {boolean} desc
     * @param {string} [filters] Search Filters
     * @param {string} [orderBy]
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [text]
     * @param {File} [image]
     * @param {string} [item]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectAnalysisSearch(
      projectHash: string,
      domain: AnalysisDomain,
      desc: boolean,
      filters?: string,
      orderBy?: string,
      offset?: number,
      limit?: number,
      text?: string,
      image?: File,
      item?: string,
      options?: any
    ): AxiosPromise<AnalysisSearch> {
      return localVarFp
        .routeProjectAnalysisSearch(
          projectHash,
          domain,
          desc,
          filters,
          orderBy,
          offset,
          limit,
          text,
          image,
          item,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Analysis Search
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {boolean} desc
     * @param {string} [filters] Search Filters
     * @param {string} [orderBy]
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [text]
     * @param {File} [image]
     * @param {string} [item]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectAnalysisSearch_16(
      projectHash: string,
      domain: AnalysisDomain,
      desc: boolean,
      filters?: string,
      orderBy?: string,
      offset?: number,
      limit?: number,
      text?: string,
      image?: File,
      item?: string,
      options?: any
    ): AxiosPromise<AnalysisSearch> {
      return localVarFp
        .routeProjectAnalysisSearch_16(
          projectHash,
          domain,
          desc,
          filters,
          orderBy,
          offset,
          limit,
          text,
          image,
          item,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Analysis Summary
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectAnalysisSummary(
      projectHash: string,
      domain: AnalysisDomain,
      filters?: string,
      options?: any
    ): AxiosPromise<QuerySummary> {
      return localVarFp
        .routeProjectAnalysisSummary(projectHash, domain, filters, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Analysis Summary
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectAnalysisSummary_17(
      projectHash: string,
      domain: AnalysisDomain,
      filters?: string,
      options?: any
    ): AxiosPromise<QuerySummary> {
      return localVarFp
        .routeProjectAnalysisSummary_17(projectHash, domain, filters, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Compare Metric Dissimilarity
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} compareProjectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectCompareMetricDissimilarity(
      projectHash: string,
      domain: AnalysisDomain,
      compareProjectHash: string,
      options?: any
    ): AxiosPromise<MetricDissimilarityResult> {
      return localVarFp
        .routeProjectCompareMetricDissimilarity(
          projectHash,
          domain,
          compareProjectHash,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Compare Metric Dissimilarity
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} compareProjectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectCompareMetricDissimilarity_18(
      projectHash: string,
      domain: AnalysisDomain,
      compareProjectHash: string,
      options?: any
    ): AxiosPromise<MetricDissimilarityResult> {
      return localVarFp
        .routeProjectCompareMetricDissimilarity_18(
          projectHash,
          domain,
          compareProjectHash,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Data Item
     * @param {string} projectHash
     * @param {string} dataItem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectDataItem(
      projectHash: string,
      dataItem: string,
      options?: any
    ): AxiosPromise<ProjectItem> {
      return localVarFp
        .routeProjectDataItem(projectHash, dataItem, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project List Collaborators
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectListCollaborators(
      projectHash: string,
      options?: any
    ): AxiosPromise<Array<ProjectCollaboratorEntry>> {
      return localVarFp
        .routeProjectListCollaborators(projectHash, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project List Predictions
     * @param {string} projectHash
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {RouteProjectListPredictionsOrderByEnum} [orderBy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectListPredictions(
      projectHash: string,
      offset?: number,
      limit?: number,
      orderBy?: RouteProjectListPredictionsOrderByEnum,
      options?: any
    ): AxiosPromise<ListProjectPredictionResult> {
      return localVarFp
        .routeProjectListPredictions(
          projectHash,
          offset,
          limit,
          orderBy,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project List Reductions
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectListReductions(
      projectHash: string,
      options?: any
    ): AxiosPromise<ProjectList2DEmbeddingReductionResult> {
      return localVarFp
        .routeProjectListReductions(projectHash, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Metadata
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectMetadata(
      projectHash: string,
      options?: any
    ): AxiosPromise<ProjectMetadata> {
      return localVarFp
        .routeProjectMetadata(projectHash, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Raw File
     * @param {string} projectHash
     * @param {string} duHash
     * @param {number} frame
     * @param {string} [ifNoneMatch]
     * @param {string} [ifModifiedSince]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectRawFile(
      projectHash: string,
      duHash: string,
      frame: number,
      ifNoneMatch?: string,
      ifModifiedSince?: string,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .routeProjectRawFile(
          projectHash,
          duHash,
          frame,
          ifNoneMatch,
          ifModifiedSince,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Reduction Scatter
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} reductionHash
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectReductionScatterApiProjectsV2ProjectHashAnalysisDomainReductionsReductionHashSummaryGet(
      projectHash: string,
      domain: AnalysisDomain,
      reductionHash: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: any
    ): AxiosPromise<Query2DEmbedding> {
      return localVarFp
        .routeProjectReductionScatterApiProjectsV2ProjectHashAnalysisDomainReductionsReductionHashSummaryGet(
          projectHash,
          domain,
          reductionHash,
          buckets,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Reduction Scatter
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} reductionHash
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectReductionScatterApiProjectsV2ProjectHashAnalysisDomainReductionsReductionHashSummaryGet_13(
      projectHash: string,
      domain: AnalysisDomain,
      reductionHash: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: any
    ): AxiosPromise<Query2DEmbedding> {
      return localVarFp
        .routeProjectReductionScatterApiProjectsV2ProjectHashAnalysisDomainReductionsReductionHashSummaryGet_13(
          projectHash,
          domain,
          reductionHash,
          buckets,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Scatter
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} xMetric
     * @param {string} yMetric
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectScatterApiProjectsV2ProjectHashAnalysisDomainScatterGet(
      projectHash: string,
      domain: AnalysisDomain,
      xMetric: string,
      yMetric: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: any
    ): AxiosPromise<QueryScatter> {
      return localVarFp
        .routeProjectScatterApiProjectsV2ProjectHashAnalysisDomainScatterGet(
          projectHash,
          domain,
          xMetric,
          yMetric,
          buckets,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Scatter
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} xMetric
     * @param {string} yMetric
     * @param {AnalysisBuckets} [buckets]
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectScatterApiProjectsV2ProjectHashAnalysisDomainScatterGet_14(
      projectHash: string,
      domain: AnalysisDomain,
      xMetric: string,
      yMetric: string,
      buckets?: AnalysisBuckets,
      filters?: string,
      options?: any
    ): AxiosPromise<QueryScatter> {
      return localVarFp
        .routeProjectScatterApiProjectsV2ProjectHashAnalysisDomainScatterGet_14(
          projectHash,
          domain,
          xMetric,
          yMetric,
          buckets,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Search
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {boolean} desc
     * @param {string} [filters] Search Filters
     * @param {string} [orderBy]
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectSearchApiProjectsV2ProjectHashAnalysisDomainSearchPost(
      projectHash: string,
      domain: AnalysisDomain,
      desc: boolean,
      filters?: string,
      orderBy?: string,
      offset?: number,
      limit?: number,
      options?: any
    ): AxiosPromise<AnalysisSearch> {
      return localVarFp
        .routeProjectSearchApiProjectsV2ProjectHashAnalysisDomainSearchPost(
          projectHash,
          domain,
          desc,
          filters,
          orderBy,
          offset,
          limit,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Search
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {boolean} desc
     * @param {string} [filters] Search Filters
     * @param {string} [orderBy]
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectSearchApiProjectsV2ProjectHashAnalysisDomainSearchPost_15(
      projectHash: string,
      domain: AnalysisDomain,
      desc: boolean,
      filters?: string,
      orderBy?: string,
      offset?: number,
      limit?: number,
      options?: any
    ): AxiosPromise<AnalysisSearch> {
      return localVarFp
        .routeProjectSearchApiProjectsV2ProjectHashAnalysisDomainSearchPost_15(
          projectHash,
          domain,
          desc,
          filters,
          orderBy,
          offset,
          limit,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Summary
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectSummaryApiProjectsV2ProjectHashAnalysisDomainSummaryGet(
      projectHash: string,
      domain: AnalysisDomain,
      filters?: string,
      options?: any
    ): AxiosPromise<QuerySummary> {
      return localVarFp
        .routeProjectSummaryApiProjectsV2ProjectHashAnalysisDomainSummaryGet(
          projectHash,
          domain,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Summary
     * @param {string} projectHash
     * @param {AnalysisDomain} domain
     * @param {string} [filters] Search Filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectSummaryApiProjectsV2ProjectHashAnalysisDomainSummaryGet_16(
      projectHash: string,
      domain: AnalysisDomain,
      filters?: string,
      options?: any
    ): AxiosPromise<QuerySummary> {
      return localVarFp
        .routeProjectSummaryApiProjectsV2ProjectHashAnalysisDomainSummaryGet_16(
          projectHash,
          domain,
          filters,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Project Summary
     * @param {string} projectHash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeProjectSummary(
      projectHash: string,
      options?: any
    ): AxiosPromise<ProjectSummary> {
      return localVarFp
        .routeProjectSummary(projectHash, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Update Tag
     * @param {string} projectHash
     * @param {string} tagHash
     * @param {ProjectTagRequest} projectTagRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeUpdateTag(
      projectHash: string,
      tagHash: string,
      projectTagRequest: ProjectTagRequest,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .routeUpdateTag(projectHash, tagHash, projectTagRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Route Update Tag
     * @param {string} projectHash
     * @param {string} tagHash
     * @param {ProjectTagRequest} projectTagRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    routeUpdateTag_19(
      projectHash: string,
      tagHash: string,
      projectTagRequest: ProjectTagRequest,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .routeUpdateTag_19(projectHash, tagHash, projectTagRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ProjectApi - object-oriented interface
 * @export
 * @class ProjectApi
 * @extends {BaseAPI}
 */
export class ProjectApi extends BaseAPI {
  /**
   *
   * @summary Route Action Create Project Subset
   * @param {string} projectHash
   * @param {CreateProjectSubsetPostAction} createProjectSubsetPostAction
   * @param {boolean} [remoteOnly]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeActionCreateProjectSubset(
    projectHash: string,
    createProjectSubsetPostAction: CreateProjectSubsetPostAction,
    remoteOnly?: boolean,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeActionCreateProjectSubset(
        projectHash,
        createProjectSubsetPostAction,
        remoteOnly,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Action Create Project Subset
   * @param {string} projectHash
   * @param {CreateProjectSubsetPostAction} createProjectSubsetPostAction
   * @param {boolean} [remoteOnly]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeActionCreateProjectSubset_1(
    projectHash: string,
    createProjectSubsetPostAction: CreateProjectSubsetPostAction,
    remoteOnly?: boolean,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeActionCreateProjectSubset_1(
        projectHash,
        createProjectSubsetPostAction,
        remoteOnly,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Action Upload Project To Encord
   * @param {string} projectHash
   * @param {UploadProjectToEncordPostAction} uploadProjectToEncordPostAction
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeActionUploadProjectToEncord(
    projectHash: string,
    uploadProjectToEncordPostAction: UploadProjectToEncordPostAction,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeActionUploadProjectToEncord(
        projectHash,
        uploadProjectToEncordPostAction,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Action Upload Project To Encord
   * @param {string} projectHash
   * @param {UploadProjectToEncordPostAction} uploadProjectToEncordPostAction
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeActionUploadProjectToEncord_2(
    projectHash: string,
    uploadProjectToEncordPostAction: UploadProjectToEncordPostAction,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeActionUploadProjectToEncord_2(
        projectHash,
        uploadProjectToEncordPostAction,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Create Tags
   * @param {string} projectHash
   * @param {Array<ProjectTagRequest>} projectTagRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeCreateTags(
    projectHash: string,
    projectTagRequest: Array<ProjectTagRequest>,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeCreateTags(projectHash, projectTagRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Create Tags
   * @param {string} projectHash
   * @param {Array<ProjectTagRequest>} projectTagRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeCreateTags_3(
    projectHash: string,
    projectTagRequest: Array<ProjectTagRequest>,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeCreateTags_3(projectHash, projectTagRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Delete Tag
   * @param {string} projectHash
   * @param {Array<string>} requestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeDeleteTag(
    projectHash: string,
    requestBody: Array<string>,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeDeleteTag(projectHash, requestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Delete Tag
   * @param {string} projectHash
   * @param {Array<string>} requestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeDeleteTag_4(
    projectHash: string,
    requestBody: Array<string>,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeDeleteTag_4(projectHash, requestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Filter All Tags
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {SearchFilters} searchFilters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeFilterAllTags(
    projectHash: string,
    domain: AnalysisDomain,
    searchFilters: SearchFilters,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeFilterAllTags(projectHash, domain, searchFilters, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Filter All Tags
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {SearchFilters} searchFilters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeFilterAllTags_5(
    projectHash: string,
    domain: AnalysisDomain,
    searchFilters: SearchFilters,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeFilterAllTags_5(projectHash, domain, searchFilters, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Filter Tag All
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {BodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost} bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeFilterTagAll(
    projectHash: string,
    domain: AnalysisDomain,
    bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost: BodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeFilterTagAll(
        projectHash,
        domain,
        bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Filter Tag All
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {BodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost} bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeFilterTagAll_6(
    projectHash: string,
    domain: AnalysisDomain,
    bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost: BodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeFilterTagAll_6(
        projectHash,
        domain,
        bodyRouteFilterTagAllApiProjectsV2ProjectHashTagsDomainFilterTagAllPost,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Filter Untag All
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {BodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost} bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeFilterUntagAll(
    projectHash: string,
    domain: AnalysisDomain,
    bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost: BodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeFilterUntagAll(
        projectHash,
        domain,
        bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Filter Untag All
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {BodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost} bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeFilterUntagAll_7(
    projectHash: string,
    domain: AnalysisDomain,
    bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost: BodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeFilterUntagAll_7(
        projectHash,
        domain,
        bodyRouteFilterUntagAllApiProjectsV2ProjectHashTagsDomainFilterUntagAllPost,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Items All Tags
   * @param {string} projectHash
   * @param {Array<string>} requestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeItemsAllTags(
    projectHash: string,
    requestBody: Array<string>,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeItemsAllTags(projectHash, requestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Items All Tags
   * @param {string} projectHash
   * @param {Array<string>} requestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeItemsAllTags_8(
    projectHash: string,
    requestBody: Array<string>,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeItemsAllTags_8(projectHash, requestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Items Tag All
   * @param {string} projectHash
   * @param {BodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost} bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeItemsTagAll(
    projectHash: string,
    bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost: BodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeItemsTagAll(
        projectHash,
        bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Items Tag All
   * @param {string} projectHash
   * @param {BodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost} bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeItemsTagAll_9(
    projectHash: string,
    bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost: BodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeItemsTagAll_9(
        projectHash,
        bodyRouteItemsTagAllApiProjectsV2ProjectHashTagsItemsTagAllPost,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Items Untag All
   * @param {string} projectHash
   * @param {BodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost} bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeItemsUntagAll(
    projectHash: string,
    bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost: BodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeItemsUntagAll(
        projectHash,
        bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Items Untag All
   * @param {string} projectHash
   * @param {BodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost} bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeItemsUntagAll_10(
    projectHash: string,
    bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost: BodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeItemsUntagAll_10(
        projectHash,
        bodyRouteItemsUntagAllApiProjectsV2ProjectHashTagsItemsUntagAllPost,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route List Projects
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeListProjects(options?: AxiosRequestConfig) {
    return ProjectApiFp(this.configuration)
      .routeListProjects(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route List Tags
   * @param {string} projectHash
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeListTags(projectHash: string, options?: AxiosRequestConfig) {
    return ProjectApiFp(this.configuration)
      .routeListTags(projectHash, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route List Tags Meta
   * @param {string} projectHash
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeListTagsMeta(projectHash: string, options?: AxiosRequestConfig) {
    return ProjectApiFp(this.configuration)
      .routeListTagsMeta(projectHash, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route List Tags Meta
   * @param {string} projectHash
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeListTagsMeta_11(
    projectHash: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeListTagsMeta_11(projectHash, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route List Tags
   * @param {string} projectHash
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeListTags_12(projectHash: string, options?: AxiosRequestConfig) {
    return ProjectApiFp(this.configuration)
      .routeListTags_12(projectHash, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Prediction Data Item
   * @param {string} projectHash
   * @param {string} predictionHash
   * @param {string} dataItem
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routePredictionDataItem(
    projectHash: string,
    predictionHash: string,
    dataItem: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routePredictionDataItem(projectHash, predictionHash, dataItem, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Prediction Distribution
   * @param {string} projectHash
   * @param {string} predictionHash
   * @param {PredictionDomain} domain
   * @param {number} iou
   * @param {string} group
   * @param {AnalysisBuckets} [buckets]
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routePredictionDistribution(
    projectHash: string,
    predictionHash: string,
    domain: PredictionDomain,
    iou: number,
    group: string,
    buckets?: AnalysisBuckets,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routePredictionDistribution(
        projectHash,
        predictionHash,
        domain,
        iou,
        group,
        buckets,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Prediction Metric Performance
   * @param {string} projectHash
   * @param {string} predictionHash
   * @param {number} iou
   * @param {string} metricName
   * @param {AnalysisBuckets} [buckets]
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routePredictionMetricPerformance(
    projectHash: string,
    predictionHash: string,
    iou: number,
    metricName: string,
    buckets?: AnalysisBuckets,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routePredictionMetricPerformance(
        projectHash,
        predictionHash,
        iou,
        metricName,
        buckets,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Prediction Reduction Scatter
   * @param {string} projectHash
   * @param {string} predictionHash
   * @param {PredictionDomain} domain
   * @param {string} reductionHash
   * @param {number} iou
   * @param {AnalysisBuckets} [buckets]
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routePredictionReductionScatter(
    projectHash: string,
    predictionHash: string,
    domain: PredictionDomain,
    reductionHash: string,
    iou: number,
    buckets?: AnalysisBuckets,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routePredictionReductionScatter(
        projectHash,
        predictionHash,
        domain,
        reductionHash,
        iou,
        buckets,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Prediction Scatter
   * @param {string} projectHash
   * @param {string} predictionHash
   * @param {PredictionDomain} domain
   * @param {number} iou
   * @param {string} xMetric
   * @param {string} yMetric
   * @param {AnalysisBuckets} [buckets]
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routePredictionScatter(
    projectHash: string,
    predictionHash: string,
    domain: PredictionDomain,
    iou: number,
    xMetric: string,
    yMetric: string,
    buckets?: AnalysisBuckets,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routePredictionScatter(
        projectHash,
        predictionHash,
        domain,
        iou,
        xMetric,
        yMetric,
        buckets,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Prediction Search
   * @param {string} projectHash
   * @param {string} predictionHash
   * @param {PredictionDomain} domain
   * @param {number} iou
   * @param {boolean} desc
   * @param {string} [filters] Search Filters
   * @param {string} [orderBy]
   * @param {number} [offset]
   * @param {number} [limit]
   * @param {string} [text]
   * @param {File} [image]
   * @param {string} [item]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routePredictionSearch(
    projectHash: string,
    predictionHash: string,
    domain: PredictionDomain,
    iou: number,
    desc: boolean,
    filters?: string,
    orderBy?: string,
    offset?: number,
    limit?: number,
    text?: string,
    image?: File,
    item?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routePredictionSearch(
        projectHash,
        predictionHash,
        domain,
        iou,
        desc,
        filters,
        orderBy,
        offset,
        limit,
        text,
        image,
        item,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Prediction Summary
   * @param {string} predictionHash
   * @param {string} projectHash
   * @param {number} iou
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routePredictionSummary(
    predictionHash: string,
    projectHash: string,
    iou: number,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routePredictionSummary(
        predictionHash,
        projectHash,
        iou,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Action Tag Items
   * @param {string} projectHash
   * @param {string} tagName
   * @param {Array<string>} requestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeProjectActionTagItems(
    projectHash: string,
    tagName: string,
    requestBody: Array<string>,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeProjectActionTagItems(projectHash, tagName, requestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Analysis Distribution
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {string} group
   * @param {AnalysisBuckets} [buckets]
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeProjectAnalysisDistribution(
    projectHash: string,
    domain: AnalysisDomain,
    group: string,
    buckets?: AnalysisBuckets,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeProjectAnalysisDistribution(
        projectHash,
        domain,
        group,
        buckets,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Analysis Distribution
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {string} group
   * @param {AnalysisBuckets} [buckets]
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeProjectAnalysisDistribution_13(
    projectHash: string,
    domain: AnalysisDomain,
    group: string,
    buckets?: AnalysisBuckets,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeProjectAnalysisDistribution_13(
        projectHash,
        domain,
        group,
        buckets,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Analysis Reduction Scatter
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {string} reductionHash
   * @param {AnalysisBuckets} [buckets]
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeProjectAnalysisReductionScatter(
    projectHash: string,
    domain: AnalysisDomain,
    reductionHash: string,
    buckets?: AnalysisBuckets,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeProjectAnalysisReductionScatter(
        projectHash,
        domain,
        reductionHash,
        buckets,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Analysis Reduction Scatter
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {string} reductionHash
   * @param {AnalysisBuckets} [buckets]
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeProjectAnalysisReductionScatter_14(
    projectHash: string,
    domain: AnalysisDomain,
    reductionHash: string,
    buckets?: AnalysisBuckets,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeProjectAnalysisReductionScatter_14(
        projectHash,
        domain,
        reductionHash,
        buckets,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Analysis Scatter
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {string} xMetric
   * @param {string} yMetric
   * @param {AnalysisBuckets} [buckets]
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeProjectAnalysisScatter(
    projectHash: string,
    domain: AnalysisDomain,
    xMetric: string,
    yMetric: string,
    buckets?: AnalysisBuckets,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeProjectAnalysisScatter(
        projectHash,
        domain,
        xMetric,
        yMetric,
        buckets,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Analysis Scatter
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {string} xMetric
   * @param {string} yMetric
   * @param {AnalysisBuckets} [buckets]
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeProjectAnalysisScatter_15(
    projectHash: string,
    domain: AnalysisDomain,
    xMetric: string,
    yMetric: string,
    buckets?: AnalysisBuckets,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeProjectAnalysisScatter_15(
        projectHash,
        domain,
        xMetric,
        yMetric,
        buckets,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Analysis Search
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {boolean} desc
   * @param {string} [filters] Search Filters
   * @param {string} [orderBy]
   * @param {number} [offset]
   * @param {number} [limit]
   * @param {string} [text]
   * @param {File} [image]
   * @param {string} [item]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeProjectAnalysisSearch(
    projectHash: string,
    domain: AnalysisDomain,
    desc: boolean,
    filters?: string,
    orderBy?: string,
    offset?: number,
    limit?: number,
    text?: string,
    image?: File,
    item?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeProjectAnalysisSearch(
        projectHash,
        domain,
        desc,
        filters,
        orderBy,
        offset,
        limit,
        text,
        image,
        item,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Analysis Search
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {boolean} desc
   * @param {string} [filters] Search Filters
   * @param {string} [orderBy]
   * @param {number} [offset]
   * @param {number} [limit]
   * @param {string} [text]
   * @param {File} [image]
   * @param {string} [item]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeProjectAnalysisSearch_16(
    projectHash: string,
    domain: AnalysisDomain,
    desc: boolean,
    filters?: string,
    orderBy?: string,
    offset?: number,
    limit?: number,
    text?: string,
    image?: File,
    item?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeProjectAnalysisSearch_16(
        projectHash,
        domain,
        desc,
        filters,
        orderBy,
        offset,
        limit,
        text,
        image,
        item,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Analysis Summary
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeProjectAnalysisSummary(
    projectHash: string,
    domain: AnalysisDomain,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeProjectAnalysisSummary(projectHash, domain, filters, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Analysis Summary
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeProjectAnalysisSummary_17(
    projectHash: string,
    domain: AnalysisDomain,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeProjectAnalysisSummary_17(projectHash, domain, filters, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Compare Metric Dissimilarity
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {string} compareProjectHash
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeProjectCompareMetricDissimilarity(
    projectHash: string,
    domain: AnalysisDomain,
    compareProjectHash: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeProjectCompareMetricDissimilarity(
        projectHash,
        domain,
        compareProjectHash,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Compare Metric Dissimilarity
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {string} compareProjectHash
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeProjectCompareMetricDissimilarity_18(
    projectHash: string,
    domain: AnalysisDomain,
    compareProjectHash: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeProjectCompareMetricDissimilarity_18(
        projectHash,
        domain,
        compareProjectHash,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Data Item
   * @param {string} projectHash
   * @param {string} dataItem
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeProjectDataItem(
    projectHash: string,
    dataItem: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeProjectDataItem(projectHash, dataItem, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project List Collaborators
   * @param {string} projectHash
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeProjectListCollaborators(
    projectHash: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeProjectListCollaborators(projectHash, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project List Predictions
   * @param {string} projectHash
   * @param {number} [offset]
   * @param {number} [limit]
   * @param {RouteProjectListPredictionsOrderByEnum} [orderBy]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeProjectListPredictions(
    projectHash: string,
    offset?: number,
    limit?: number,
    orderBy?: RouteProjectListPredictionsOrderByEnum,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeProjectListPredictions(projectHash, offset, limit, orderBy, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project List Reductions
   * @param {string} projectHash
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeProjectListReductions(
    projectHash: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeProjectListReductions(projectHash, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Metadata
   * @param {string} projectHash
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeProjectMetadata(
    projectHash: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeProjectMetadata(projectHash, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Raw File
   * @param {string} projectHash
   * @param {string} duHash
   * @param {number} frame
   * @param {string} [ifNoneMatch]
   * @param {string} [ifModifiedSince]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeProjectRawFile(
    projectHash: string,
    duHash: string,
    frame: number,
    ifNoneMatch?: string,
    ifModifiedSince?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeProjectRawFile(
        projectHash,
        duHash,
        frame,
        ifNoneMatch,
        ifModifiedSince,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Reduction Scatter
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {string} reductionHash
   * @param {AnalysisBuckets} [buckets]
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeProjectReductionScatterApiProjectsV2ProjectHashAnalysisDomainReductionsReductionHashSummaryGet(
    projectHash: string,
    domain: AnalysisDomain,
    reductionHash: string,
    buckets?: AnalysisBuckets,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeProjectReductionScatterApiProjectsV2ProjectHashAnalysisDomainReductionsReductionHashSummaryGet(
        projectHash,
        domain,
        reductionHash,
        buckets,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Reduction Scatter
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {string} reductionHash
   * @param {AnalysisBuckets} [buckets]
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeProjectReductionScatterApiProjectsV2ProjectHashAnalysisDomainReductionsReductionHashSummaryGet_13(
    projectHash: string,
    domain: AnalysisDomain,
    reductionHash: string,
    buckets?: AnalysisBuckets,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeProjectReductionScatterApiProjectsV2ProjectHashAnalysisDomainReductionsReductionHashSummaryGet_13(
        projectHash,
        domain,
        reductionHash,
        buckets,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Scatter
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {string} xMetric
   * @param {string} yMetric
   * @param {AnalysisBuckets} [buckets]
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeProjectScatterApiProjectsV2ProjectHashAnalysisDomainScatterGet(
    projectHash: string,
    domain: AnalysisDomain,
    xMetric: string,
    yMetric: string,
    buckets?: AnalysisBuckets,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeProjectScatterApiProjectsV2ProjectHashAnalysisDomainScatterGet(
        projectHash,
        domain,
        xMetric,
        yMetric,
        buckets,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Scatter
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {string} xMetric
   * @param {string} yMetric
   * @param {AnalysisBuckets} [buckets]
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeProjectScatterApiProjectsV2ProjectHashAnalysisDomainScatterGet_14(
    projectHash: string,
    domain: AnalysisDomain,
    xMetric: string,
    yMetric: string,
    buckets?: AnalysisBuckets,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeProjectScatterApiProjectsV2ProjectHashAnalysisDomainScatterGet_14(
        projectHash,
        domain,
        xMetric,
        yMetric,
        buckets,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Search
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {boolean} desc
   * @param {string} [filters] Search Filters
   * @param {string} [orderBy]
   * @param {number} [offset]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeProjectSearchApiProjectsV2ProjectHashAnalysisDomainSearchPost(
    projectHash: string,
    domain: AnalysisDomain,
    desc: boolean,
    filters?: string,
    orderBy?: string,
    offset?: number,
    limit?: number,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeProjectSearchApiProjectsV2ProjectHashAnalysisDomainSearchPost(
        projectHash,
        domain,
        desc,
        filters,
        orderBy,
        offset,
        limit,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Search
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {boolean} desc
   * @param {string} [filters] Search Filters
   * @param {string} [orderBy]
   * @param {number} [offset]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeProjectSearchApiProjectsV2ProjectHashAnalysisDomainSearchPost_15(
    projectHash: string,
    domain: AnalysisDomain,
    desc: boolean,
    filters?: string,
    orderBy?: string,
    offset?: number,
    limit?: number,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeProjectSearchApiProjectsV2ProjectHashAnalysisDomainSearchPost_15(
        projectHash,
        domain,
        desc,
        filters,
        orderBy,
        offset,
        limit,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Summary
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeProjectSummaryApiProjectsV2ProjectHashAnalysisDomainSummaryGet(
    projectHash: string,
    domain: AnalysisDomain,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeProjectSummaryApiProjectsV2ProjectHashAnalysisDomainSummaryGet(
        projectHash,
        domain,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Summary
   * @param {string} projectHash
   * @param {AnalysisDomain} domain
   * @param {string} [filters] Search Filters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeProjectSummaryApiProjectsV2ProjectHashAnalysisDomainSummaryGet_16(
    projectHash: string,
    domain: AnalysisDomain,
    filters?: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeProjectSummaryApiProjectsV2ProjectHashAnalysisDomainSummaryGet_16(
        projectHash,
        domain,
        filters,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Project Summary
   * @param {string} projectHash
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeProjectSummary(
    projectHash: string,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeProjectSummary(projectHash, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Update Tag
   * @param {string} projectHash
   * @param {string} tagHash
   * @param {ProjectTagRequest} projectTagRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeUpdateTag(
    projectHash: string,
    tagHash: string,
    projectTagRequest: ProjectTagRequest,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeUpdateTag(projectHash, tagHash, projectTagRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Route Update Tag
   * @param {string} projectHash
   * @param {string} tagHash
   * @param {ProjectTagRequest} projectTagRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectApi
   */
  public routeUpdateTag_19(
    projectHash: string,
    tagHash: string,
    projectTagRequest: ProjectTagRequest,
    options?: AxiosRequestConfig
  ) {
    return ProjectApiFp(this.configuration)
      .routeUpdateTag_19(projectHash, tagHash, projectTagRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const RouteProjectListPredictionsOrderByEnum = {
  Empty: "",
} as const;
export type RouteProjectListPredictionsOrderByEnum =
  (typeof RouteProjectListPredictionsOrderByEnum)[keyof typeof RouteProjectListPredictionsOrderByEnum];
